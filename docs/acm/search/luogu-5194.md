+++
tags = ["dfs"]
+++

# 洛谷P5194 [USACO05DEC] Scales S

约翰有一架用来称牛的体重的天平。与之配套的是 $N$ ( $1 \leq N \leq 1000$ )个已知质量的砝码（所有砝码质量的数值都在32位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $C$ ( $1 \leq C \leq 2^{30}$ )时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第3个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$ ，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## Input

第1行输入两个用空格隔开的正整数 $N$ 和 $C$ 。

第2到 $N+1$ 行：每一行仅包含一个正整数，即某个砝码的质量。保证这些砝码的质量是一个不下降序列。

## Output

输出一个正整数，表示用所给的砝码能称出的不压坏天平的最大质量。

## Sample Input

```
3 15
1
10
20
```

## Sample Output

```
11
```

## Solution

砝码重量从大到小dfs，每个砝码只有加入和不加入两种状态。注意加入剪枝，即如果前面所有的砝码之和d可以全部选上就直接选上即可。

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1007;
int n;
long long c, a[MAXN], sa[MAXN], ans;

void dfs(int i, long long sum) {
  if (i >= 0) {
    if (sa[i] + sum <= c)
      ans = max(ans, sa[i] + sum);
    else {
      ans = max(ans, sum);
      dfs(i-1, sum);
      long long ss = sum + a[i];
      if (ss <= c) {
        ans = max(ss, ans);
        dfs(i-1, ss);
      }
    }
  }
}

int main() {
  scanf("%d%lld", &n, &c);
  for (int i = 0; i < n; i ++)
    scanf("%lld", &a[i]);
  sa[0] = a[0];
  for (int i = 1; i < n; i ++)
    sa[i] = a[i] + sa[i-1];
  dfs(n-1, 0);
  printf("%lld", ans);
  return 0;
}
```
