(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d22669c"],{e90b:function(t){t.exports=JSON.parse('{"created_at":"2020-07-22T12:51:20+08:00","excerpt":"> 2020春算法设计与分析课程笔记，教材为算法导论（CLRS）和 Algorithm Design（K&R），此部分包括复杂度分析、贪心、分治、P/NP、NPC问题、近似算法、随机算法、局部搜索，其他部分见[图论笔记](graph)、[动态规划笔记](dp)，通过大量例子来学习算法的设计、正确性证明、复杂度分析。","html":"<blockquote>\\n<p>2020春算法设计与分析课程笔记，教材为算法导论（CLRS）和 Algorithm Design（K&amp;R），此部分包括复杂度分析、贪心、分治、P/NP、NPC问题、近似算法、随机算法、局部搜索，其他部分见<a href=\\"graph\\">图论笔记</a>、<a href=\\"dp\\">动态规划笔记</a>，通过大量例子来学习算法的设计、正确性证明、复杂度分析。</p>\\n</blockquote>\\n<p>题型：9题左右</p>\\n<ol>\\n<li>判断题</li>\\n<li>问答题（复杂度，递归式的复杂度、master）</li>\\n<li>设计算法、证明NPC</li>\\n</ol>\\n<p>复习进度：分治、贪心、最短路、网络流（分点、超级源超级汇、Baseball Elimination）、近似算法、随机算法、局部搜索</p>\\n<h2 id=\\"_1\\">复杂度分析</h2>\\n<p>求解方程的三种常用方法：主定理（Master Theorem），递归树，数学归纳法</p>\\n<p>主定理（可用递归树方法证明）：<script type=\\"math/tex\\">T(n)=aT(n/b)+f(n)<\/script>的解，其中<script type=\\"math/tex\\">a\\\\ge 1, b>0, f(n)\\\\ge 0<\/script>\\n</p>\\n<ol>\\n<li>若<script type=\\"math/tex\\">\\\\exists \\\\epsilon>0,f(n)=O(n^{log_b a-\\\\epsilon})<\/script>，则<script type=\\"math/tex\\">T(n)=\\\\Theta(n^{\\\\log_b a})<\/script>\\n</li>\\n<li>若<script type=\\"math/tex\\">f(n)=\\\\Theta (n^{log_b a})<\/script>，则<script type=\\"math/tex\\">T(n)=\\\\Theta(n^{\\\\log_b a} \\\\log n)<\/script>\\n</li>\\n<li>若<script type=\\"math/tex\\">\\\\exists \\\\epsilon > 0, f(n)=\\\\Omega(n^{log_b a+\\\\epsilon})<\/script>，且<script type=\\"math/tex\\">\\\\exists c>0,n_0> 0 ,\\\\forall n > n_0, af(n/b)\\\\le cf(n)<\/script>，则<script type=\\"math/tex\\">T(n)=\\\\Theta(f(n))<\/script>\\n</li>\\n</ol>\\n<h2 id=\\"_2\\">贪心</h2>\\n<h3 id=\\"interval-scheduling\\">Interval Scheduling</h3>\\n<p>给定n个区间，不相交区间数最多有几个</p>\\n<p>算法：按右端点排序后尽可能地加入即可</p>\\n<p>正确性证明：考虑算法所得区间集合和最优区间集合（排序后），不妨设算法所得前r个区间同最优解，而第r+1个区间和最优解不同，则由算法过程可知，此区间的右端点必早于最优解的第r+1个区间，于是我们可以替换掉最优解中这个区间而得到一个不差的解。</p>\\n<h3 id=\\"interval-partitioning\\">Interval Partitioning</h3>\\n<p>给定n个课的时间区间，如何安排排课所需教室最少</p>\\n<p>按左端点排序后依次加入，遍历当前所有教室，若可以排则排，否则添加一个新教室排进去。</p>\\n<p>正确性证明：</p>\\n<p>TODO</p>\\n<h3 id=\\"scheduling-to-minimize-latency\\">Scheduling to Minimize Latency</h3>\\n<p>给定n个工件，工件i有加工所需时间<script type=\\"math/tex\\">t_i<\/script>和交工DDL时间<script type=\\"math/tex\\">d_i<\/script>，若其开始时间为<script type=\\"math/tex\\">s_i<\/script>，则延迟定义为<script type=\\"math/tex\\">l_i=\\\\max(s_i +t_i-d_i, 0)<\/script>，求这些工件的一个排序，使得所有工件的延迟的最大值最小</p>\\n<p>算法：DDL优先</p>\\n<p>正确性证明（相邻交换法）：考虑相邻两个工件i, j，令<script type=\\"math/tex\\">s=\\\\min(s_i, s_j)<\/script>，考虑这两个工件的延迟的最大值，令i在j前时和i在j后时分别为<script type=\\"math/tex\\">l_1, l_2<\/script>，易知</p>\\n<p>\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\nl_1 &= \\\\max(0, s + t_i - d_i, s_i + t_i + t_j - d_j)\\\\\\\\\\nl_2 &= \\\\max(0, s + t_j - d_j, s + t_i + t_j - d_i)\\\\\\\\\\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<p>若<script type=\\"math/tex\\">d_i < d_j<\/script>，显然<script type=\\"math/tex\\">l_1 \\\\le l_2<\/script>，即i在j前更优。</p>\\n<h2 id=\\"_3\\">分治</h2>\\n<p>归并算法、求逆序对数、和最大的连续子数组略，易证<script type=\\"math/tex\\">O(n\\\\log n)<\/script>\\n</p>\\n<h3 id=\\"_4\\">随机化快排</h3>\\n<p>复杂度显然为<script type=\\"math/tex\\">O(n\\\\log n)<\/script>\\n</p>\\n<p>证明：令<script type=\\"math/tex\\">T(n)<\/script>为规模n的随机化快排时间期望</p>\\n<p>\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\nT(n) &= \\\\begin{cases}\\nT(0) + T(n-1) + \\\\Theta(n)\\\\\\\\\\nT(1) + T(n-2) + \\\\Theta(n)\\\\\\\\\\n...\\\\\\\\\\nT(n-1) + T(0) + \\\\Theta(n)\\\\\\\\\\n\\\\end{cases}\\\\\\\\\\n&= \\\\frac{1}{n}\\\\left[\\\\sum_{i=0}^{n-1} T(i) + T(n-1-i)\\\\right] + \\\\Theta(n) \\\\\\\\\\n&= \\\\frac{2}{n}\\\\sum_{i=0}^{n-1} T(i) + \\\\Theta(n) \\\\\\\\\\n&= \\\\frac{2}{n}\\\\sum_{i=2}^{n-1} T(i) + \\\\Theta(n) \\\\\\\\\\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<p>其中第二行用了期望的线性性，第四行将 <script type=\\"math/tex\\">T(0)<\/script> 和 <script type=\\"math/tex\\">T(1)<\/script> 归入了<script type=\\"math/tex\\">\\\\Theta(n)<\/script>。之后用代换法可以证明，其中求和<script type=\\"math/tex\\">\\\\sum i \\\\log i<\/script>用黎曼上和不等式即可。</p>\\n<h3 id=\\"_5\\">最近点对问题</h3>\\n<p>问题：给定二维平面上的n个点的坐标，求点对之间欧式距离的最小值</p>\\n<p>分治算法：</p>\\n<ol>\\n<li>先按x排序，用直线<script type=\\"math/tex\\">x=x_0<\/script>平面切成点数几乎相同的左右两部分，令<script type=\\"math/tex\\">\\\\delta<\/script>为这两个部分的最近点对距离的最小值。接下来只需考虑一点在左平面，一点在右平面的点对情况。易证，只需在直线<script type=\\"math/tex\\">x=x_0 \\\\pm \\\\delta<\/script>之间寻找即可。若将这其中的区域用<script type=\\"math/tex\\">\\\\frac{\\\\delta}{2}<\/script>边长的正方形平铺（即每行4个，恰2个在左平面，2个在右平面），易证，每一个小正方形内至多有1个点，且相隔2行以外的点距离大于必<script type=\\"math/tex\\">\\\\delta<\/script>，不用考虑之。</li>\\n<li>于是将直线<script type=\\"math/tex\\">x=x_0 \\\\pm \\\\delta<\/script>之间的点按y排序，对于每个点，考虑其和之后11个点的距离即可（11其实可以更小）。排序可以在一开使完成，或由子调用完成。</li>\\n</ol>\\n<p>用主定理易知得<script type=\\"math/tex\\">T(n)=n\\\\log n<\/script>\\n</p>\\n<p>O(n)算法见随机算法一节</p>\\n<h3 id=\\"_6\\">整数乘法</h3>\\n<p>计算两个n位整数<script type=\\"math/tex\\">x, y<\/script>的乘法，令x的高低<script type=\\"math/tex\\">\\\\frac{n}{2}<\/script>位为<script type=\\"math/tex\\">x_1, x_0<\/script>，y的高低<script type=\\"math/tex\\">\\\\frac{n}{2}<\/script>位为<script type=\\"math/tex\\">y_1, y_0<\/script>，可知\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\nxy = 2^n x_1 y_1 + x_0 y_0 + 2^n\\\\left[(x_0+y_0)(x_1 + y_1) - x_1 y_1 - x_0 y_0\\\\right]\\n\\\\end{aligned}\\n<\/script>\\n于是只需要计算三次乘法即可，即<script type=\\"math/tex\\">T(n)=3T(n/2)+O(n)<\/script>，解得<script type=\\"math/tex\\">T(n)=n^{\\\\log_2 3}<\/script>\\n</p>\\n<h3 id=\\"_7\\">矩阵乘法</h3>\\n<p>Strassen’s algorithm</p>\\n<p>非2次幂的情况可以补零至2次幂</p>\\n<h3 id=\\"fft\\">FFT</h3>\\n<p>在<script type=\\"math/tex\\">O(n\\\\log n)<\/script>的时间内计算两个n次多项式的乘积，由于多项式相乘本质上是一个卷积，故也可在<script type=\\"math/tex\\">O(n\\\\log n)<\/script>时间内计算卷积。其基本步骤如下</p>\\n<ol>\\n<li>将n-1次多项式<script type=\\"math/tex\\">A(x), B(x)<\/script>补零至2n-1次多项式<script type=\\"math/tex\\">A\'(x), B\'(x)<\/script>\\n</li>\\n<li>用DFT计算<script type=\\"math/tex\\">A\'(w_{2n}^{i}), B\'(w_{2n}^{i}), i = 0, ..., 2n-1<\/script>\\n</li>\\n<li>计算<script type=\\"math/tex\\">C(w_{2n}^i)=A\'(w_{2n}^i)B\'(w_{2n}^i)<\/script>\\n</li>\\n<li>DFT反变换得到<script type=\\"math/tex\\">C(x)=A(x)B(x)<\/script>的系数</li>\\n</ol>\\n<p>其中DFT及其反变换可用FFT算法在<script type=\\"math/tex\\">O(n\\\\log n)<\/script>时间内完成，于是总复杂度为<script type=\\"math/tex\\">O(n\\\\log n)<\/script>\\n</p>\\n<h2 id=\\"pnpnpc\\">P/NP/NPC</h2>\\n<p>概念</p>\\n<ul>\\n<li>P：多项式求解，P=co-P</li>\\n<li>NP：多项式验证</li>\\n<li>NPC：任意一个NP问题都能多项式规约于一个NPC问题</li>\\n<li>NP-hard</li>\\n</ul>\\n<h3 id=\\"npc\\">NPC问题</h3>\\n<p>Circuit-SAT：NPC，证略</p>\\n<p>3-SAT问题：由n个元素构成的含k个三元子句的合取范式，能否为真？从Circuit-SAT规约</p>\\n<h4 id=\\"_8\\">最大团问题</h4>\\n<p>是否存在顶点数大于等于k的完全子图，从3-SAT规约</p>\\n<h4 id=\\"_9\\">独立集问题</h4>\\n<p>是否能找到顶点数大于等于k的独立集（所有点互不相连），从3-SAT规约（每个子句一个三角形，互补字连边）</p>\\n<h4 id=\\"_10\\">顶点覆盖问题</h4>\\n<p>能否找到顶点数大于等于k的顶点覆盖（用顶点覆盖所有边），从独立集问题规约</p>\\n<p>顶点覆盖和独立集问题的关系：V-顶点覆盖=独立集</p>\\n<p>顶点覆盖和最大团问题的关系：若G有一个点数为k的团<script type=\\"math/tex\\">V\'<\/script>，则<script type=\\"math/tex\\">V-V\'<\/script>是一个G的补图<script type=\\"math/tex\\">\\\\bar G<\/script>中的顶点覆盖</p>\\n<h4 id=\\"_11\\">集合覆盖问题</h4>\\n<p>给定集合的若干个子集，能否用其中的k个子集覆盖原集合，从顶点覆盖规约</p>\\n<h4 id=\\"_12\\">子集和问题</h4>\\n<p>从3-SAT规约</p>\\n<table>\\n<thead>\\n<tr>\\n<th>-</th>\\n<th>x</th>\\n<th>y</th>\\n<th>C1</th>\\n<th>C2</th>\\n<th></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>x</td>\\n<td>1</td>\\n<td></td>\\n<td></td>\\n<td>1</td>\\n<td>1001</td>\\n</tr>\\n<tr>\\n<td>~x</td>\\n<td>1</td>\\n<td></td>\\n<td>1</td>\\n<td></td>\\n<td>1010</td>\\n</tr>\\n<tr>\\n<td>y</td>\\n<td></td>\\n<td>1</td>\\n<td>1</td>\\n<td></td>\\n<td>0110</td>\\n</tr>\\n<tr>\\n<td>~y</td>\\n<td></td>\\n<td>1</td>\\n<td></td>\\n<td>1</td>\\n<td>0101</td>\\n</tr>\\n<tr>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>1</td>\\n<td></td>\\n<td></td>\\n</tr>\\n<tr>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td></td>\\n<td>1</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>目标值</td>\\n<td>1</td>\\n<td>1</td>\\n<td>3</td>\\n<td>3</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>哈密顿回路/路径问题：从3-SAT的规约（欧拉回路/路径属于P）</p>\\n<p>TSP问题：从哈密顿回路规约（显然）</p>\\n<p>3DM：从3-SAT规约</p>\\n<p>划分问题：从子集和问题规约</p>\\n<p>背包问题的判定形式（总价值能否大于等于某个值）：从子集和问题规约，对于每个子集，加入一个权重=价值=子集大小的背包。总权重约束=目标价值=目标子集和</p>\\n<p>顶点覆盖、独立集、集合覆盖之间的互相规约</p>\\n<h4 id=\\"_13\\">其他</h4>\\n<p>Hitting Set Problem：从顶点覆盖规约</p>\\n<p><a href=\\"https://en.wikipedia.org/wiki/Dominating_set\\">Dominating Set Problem</a>：用顶点覆盖所有顶点，从集合覆盖规约</p>\\n<h2 id=\\"_14\\">近似算法</h2>\\n<p>概念：</p>\\n<p>PTAS is an algorithm which takes an instance of an optimization problem and a parameter ε &gt; 0 and, in polynomial time, produces a solution that is within a factor 1 + ε of being optimal (or 1 − ε for maximization problems)</p>\\n<p>FPTAS (fully polynomial-time approximation scheme), which requires the algorithm to be polynomial in both the problem size n and 1/ε</p>\\n<h3 id=\\"load-balancing\\">Load Balancing</h3>\\n<p>问题：有m台机器<script type=\\"math/tex\\">M_1, ..., M_m<\/script>，n个任务所需时间分别为<script type=\\"math/tex\\">t_1, ..., t_n<\/script>，我们需要将每个任务都分配到其中一台机器上， 使得<script type=\\"math/tex\\">T = \\\\max\\\\limits_{\\\\text{machine }M_i} \\\\sum\\\\limits_{\\\\text{jobs assigned to Mi}} t_j<\/script>最小</p>\\n<p>2近似算法：每次将一个任务加入当前负载最小的机器上</p>\\n<p>证明2近似：令<script type=\\"math/tex\\">T_i<\/script>为算法最终得到的机器<script type=\\"math/tex\\">M_i<\/script>上的负载，<script type=\\"math/tex\\">T^*<\/script>为最优解。不妨设最终<script type=\\"math/tex\\">M_1<\/script>负载最大，最后一个加入的任务为<script type=\\"math/tex\\">t_1<\/script>。显然<script type=\\"math/tex\\">T^* \\\\ge \\\\frac{\\\\sum t_i}{m}<\/script>且<script type=\\"math/tex\\">T^* \\\\ge t_i, \\\\forall t_i<\/script>。又<script type=\\"math/tex\\">T_1 - t_1 \\\\le T_i<\/script>（最后一个任务加入到当前最小负载的机器<script type=\\"math/tex\\">M_1<\/script>），将m个等式相加后得<script type=\\"math/tex\\">m (T_1 - t_1) \\\\le \\\\sum t_i<\/script>，即<script type=\\"math/tex\\">T_1 \\\\le \\\\frac{\\\\sum t_i}{m} + t_1 \\\\le 2T^*<\/script>\\n</p>\\n<h3 id=\\"center-selection\\">Center Selection</h3>\\n<p>TODO</p>\\n<h3 id=\\"_15\\">最小加权集合覆盖</h3>\\n<p>U为元素全集，<script type=\\"math/tex\\">S_i<\/script>为U的权值<script type=\\"math/tex\\">w_i<\/script>的子集</p>\\n<p>贪婪，每次加入一个增益<script type=\\"math/tex\\">\\\\frac{w_i}{|S_i \\\\cap R|}<\/script>最小的集合</p>\\n<p>证明logn近似：令在算法选择集合<script type=\\"math/tex\\">S_i<\/script>后，我们让所有新增的元素<script type=\\"math/tex\\">s<\/script>的代价为<script type=\\"math/tex\\">c_{s} = \\\\frac{w_i}{|S_i \\\\cap R|}<\/script>，</p>\\n<p>若算法过程中选择了集合<script type=\\"math/tex\\">S_i<\/script>，则</p>\\n<p>显然有</p>\\n<p>\\n<script type=\\"math/tex\\">w^* =\\\\sum\\\\limits_{S_i \\\\in C^*} w_i\\\\ge \\\\sum\\\\limits_{S_i \\\\in C^*} \\\\frac{1}{H(d^*)} \\\\sum\\\\limits_{s\\\\in S_i} c_s\\\\ge \\\\frac{1}{H(d^*)} \\\\sum\\\\limits_{s\\\\in U}c_s = \\\\frac{1}{H(d^*)}\\\\sum\\\\limits_{S_i\\\\in C} w_i<\/script>\\n</p>\\n<p>TODO</p>\\n<h3 id=\\"_16\\">子集和问题</h3>\\n<p>TODO CLRS</p>\\n<h3 id=\\"_17\\">最小顶点覆盖</h3>\\n<p>2近似算法：每次选择一条边，加入边上两端点，并排除这两端点覆盖的其他边</p>\\n<p>证明2近似：</p>\\n<p>令<script type=\\"math/tex\\">A<\/script>为该算法所选边集，<script type=\\"math/tex\\">C^*<\/script>为最优顶点覆盖，<script type=\\"math/tex\\">C<\/script>为该算法所得顶点覆盖。显然<script type=\\"math/tex\\">|C| = 2|A|<\/script>，又对于每个顶点覆盖，A中每一条边至少被一个顶点覆盖，故<script type=\\"math/tex\\">|C^*| \\\\ge |A| =\\\\frac{|C\'|}{2}<\/script>。</p>\\n<h3 id=\\"_18\\">背包问题</h3>\\n<p>这里指背包问题的判定形式</p>\\n<p>由于背包问题的复杂度为<script type=\\"math/tex\\">O(VW)<\/script>和输入规模有关，考虑通过缩放来减少输入规模</p>\\n<p>近似算法：令缩放参数<script type=\\"math/tex\\">\\\\theta=\\\\epsilon v_{max} / n<\/script>，<script type=\\"math/tex\\">\\\\overline{v_i} = \\\\lceil \\\\frac{v_i}{\\\\theta}\\\\rceil \\\\theta<\/script>，<script type=\\"math/tex\\">v\'_i = \\\\lceil \\\\frac{v_i}{\\\\theta}\\\\rceil<\/script>，显然用<script type=\\"math/tex\\">\\\\overline {v_i}<\/script>求得的解和<script type=\\"math/tex\\">v’_i<\/script>相同，直觉上，用其来求解背包可近似最优解。显然算法复杂度为<script type=\\"math/tex\\">O(\\\\frac{n^3}{\\\\epsilon})<\/script>。</p>\\n<p>证明FPTAS：令<script type=\\"math/tex\\">S^*<\/script>为任意解，<script type=\\"math/tex\\">S<\/script>为算法所得解，可以证明<script type=\\"math/tex\\">\\\\sum\\\\limits_{i\\\\in S^*} v_i \\\\le \\\\sum\\\\limits_{i\\\\in S^*} \\\\overline v_i \\\\le \\\\sum\\\\limits_{i\\\\in S} \\\\overline v_i \\\\le \\\\sum\\\\limits_{i\\\\in S}( v_i + \\\\theta) \\\\le \\\\sum\\\\limits_{i\\\\in S} v_i + n\\\\theta \\\\le (1+\\\\epsilon) \\\\sum\\\\limits_{i\\\\in S} v_i<\/script>\\n</p>\\n<h3 id=\\"tsp\\">TSP</h3>\\n<p>TSP问题：在一个带<strong>非负</strong>边权的<strong>完全图</strong>上寻找最短哈密顿回路（可以通过加上边权为无穷大的边来得到完全图）</p>\\n<p>边权是否满足三角不等式<script type=\\"math/tex\\">c(u, v) + c(v, w) \\\\le c(u, w)<\/script>？若不满足，则不存在常数近似算法，除非P=NP</p>\\n<p>证明：对于一个TSP问题的多项式时间的<script type=\\"math/tex\\">\\\\rho<\/script> 近似算法，将任意哈密顿回路问题规约为TSP问题，只需令<script type=\\"math/tex\\">c(u, v)  =\\\\begin{cases} 1,& (u, v)\\\\in E\\\\\\\\ \\\\rho |V|, &\\\\text{else} \\\\end{cases}<\/script>。</p>\\n<p>近似算法（满足三角不等式的情况下）：任意选一点为根，跑MST算法得到一棵MST，其前序遍历走过+回溯的节点访问顺序去掉之前出现过的，即为输出</p>\\n<p>证明2近似：令<script type=\\"math/tex\\">c(X) = \\\\sum_{(u, v)\\\\in X} c(u, v)<\/script>，最小生成树为<script type=\\"math/tex\\">T<\/script>，其前序遍历时走过+回溯的边为<script type=\\"math/tex\\">W<\/script>，算法所得解为<script type=\\"math/tex\\">H<\/script>，最优解为<script type=\\"math/tex\\">H^*<\/script>。显然有<script type=\\"math/tex\\">c(T)\\\\le c(H^*)<\/script>和<script type=\\"math/tex\\">c(W) = 2c(T)<\/script>，易证<script type=\\"math/tex\\">c(H)\\\\le c(W)<\/script>（根据三角不等式）。故为2近似</p>\\n<p>2近似可以再优化？TODO</p>\\n<h3 id=\\"_19\\">最小加权顶点覆盖</h3>\\n<p>近似算法思路：用线性规划（LP）近似</p>\\n<p>先转化为01整数规划（0-1 integer program），令<script type=\\"math/tex\\">x(v)=0\\\\text{ or }1<\/script>表示是否选则点v，如下</p>\\n<p>\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\n\\\\min & \\\\sum_{v\\\\in V} w(v)x(v)\\\\\\\\\\n\\\\text{subject to}\\\\\\\\\\n&x(u) + x(v) \\\\ge 1,  &\\\\text{for each }(u, v)\\\\in E\\\\\\\\\\n& x(v) \\\\in \\\\{0, 1\\\\}, &\\\\text{for each } v\\\\in V \\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<p>再将<script type=\\"math/tex\\">x(v)\\\\in \\\\{0, 1\\\\}<\/script>的整形变成<script type=\\"math/tex\\">0\\\\le x(v)\\\\le 1<\/script>的连续值，求解此线性规划问题，得到解<script type=\\"math/tex\\">\\\\bar x(v),v\\\\in V<\/script>。若<script type=\\"math/tex\\">\\\\bar x(v) >= \\\\frac{1}{2}<\/script>，则选择这个点加入<script type=\\"math/tex\\">C<\/script>。输出最终得到的<script type=\\"math/tex\\">C<\/script>。</p>\\n<p>证明<script type=\\"math/tex\\">C<\/script>是顶点覆盖：</p>\\n<p>因为对于任意<script type=\\"math/tex\\">(u, v)\\\\in E<\/script>，<script type=\\"math/tex\\">\\\\bar x(u)+\\\\bar x(v)\\\\ge 1<\/script>，可知uv中至少有一个<script type=\\"math/tex\\">\\\\ge \\\\frac{1}{2}<\/script>，即至少有一个被选上，故为顶点覆盖</p>\\n<p>证明2近似：</p>\\n<p>令<script type=\\"math/tex\\">z^*=\\\\sum w(v) \\\\bar x(v)<\/script>是线性规划得到的解，令<script type=\\"math/tex\\">C^*<\/script>为最优顶点覆盖，令<script type=\\"math/tex\\">w(C) = \\\\sum_{v \\\\in C} w(v)<\/script>，易证<script type=\\"math/tex\\">2z^* \\\\ge w(C)<\/script>（将<script type=\\"math/tex\\">z^*<\/script>拆成两个求和，选入的和未选入的，再对比一下），又<script type=\\"math/tex\\">w(C^*) \\\\ge z^*<\/script>（最顶点覆盖的01整数规划解也是线性规划的可行解）。</p>\\n<h3 id=\\"_20\\">其他</h3>\\n<p>Weighted Hitting Set Problem：是<script type=\\"math/tex\\">b=\\\\max_i |B_i|<\/script>近似，类似加权顶点覆盖</p>\\n<h2 id=\\"_21\\">局部搜索</h2>\\n<p>模拟退火（Simulated Annealing，SA）：梯度下降时加入随机因素，期以跳出局部最优点</p>\\n<p>禁忌算法（Tabu Search，TS）：标记已得到得局部最优解，在之后的迭代中避之。</p>\\n<p>顶点覆盖局部搜索算法：邻居是加入或删除一个顶点的顶点覆盖，算法可以任意差</p>\\n<h3 id=\\"_22\\">最大割</h3>\\n<p>单移动算法：从任意割开始，每次（从A到B或从B到A）移动一个可以得到更优解的点</p>\\n<p>证明2近似：令算法得到割<script type=\\"math/tex\\">(A, B)<\/script>，最大割为<script type=\\"math/tex\\">(A^*, B^*)<\/script>，令<script type=\\"math/tex\\">w(A, B) = \\\\sum\\\\limits_{a\\\\in A, b\\\\in B} w(a, b)<\/script>\\n</p>\\n<p>由局部最优可知，把A中任意一点<script type=\\"math/tex\\">a_0<\/script>移动到B中不会增大割，即移动后增加量小于减少量，即</p>\\n<p>\\n<script type=\\"math/tex; mode=display\\">\\n\\\\sum_{a\\\\in A} w(a, a_0) \\\\le \\\\sum_{b\\\\in B} w(a_0, b)\\n<\/script>\\n</p>\\n<p>对所有<script type=\\"math/tex\\">a_0<\/script>相加后得\\n<script type=\\"math/tex; mode=display\\">\\n\\\\sum_{a_i, a_j \\\\in A} w(a_i, a_j) \\\\le \\\\sum_{a\\\\in A, b\\\\in B} w(a, b)=w(A, B)\\n<\/script>\\n</p>\\n<p>同理，对B有<script type=\\"math/tex\\">\\\\sum_{b_i, b_j \\\\in B} w(b_i, b_j) \\\\le w(A, B)<\/script>。</p>\\n<p>又因为最大割必然小于等于所有边权和，故有\\n<script type=\\"math/tex; mode=display\\">\\nw(A^*, B^*)\\\\le \\\\sum w(u, v) = \\\\sum w(a_i, a_j) + \\\\sum w(b_i, b_j) + w(A, B) = 2w(A, B)\\n<\/script>\\n</p>\\n<h3 id=\\"nash\\">Nash平衡</h3>\\n<p>组播传输问题：给定一个带边权（边e的费用记为<script type=\\"math/tex\\">c_e<\/script>）的图<script type=\\"math/tex\\">G = (V, E)<\/script>、一个源s和若干个汇<script type=\\"math/tex\\">t_1, ..., t_k<\/script>，代理j必须构建一条从s到<script type=\\"math/tex\\">t_j<\/script>的路径。费用均摊，即若有x个代理都用了边e，则每人在此边上付费<script type=\\"math/tex\\">\\\\frac{c_e}{x}<\/script>。如何使总费用最小？</p>\\n<p>如果每个代理都无法通过他<strong>单方</strong>的改变，而减少费用，此局部搜索算法的解称为Nash平衡，而最优解称为<em>社会最优</em>。显然这个Naive的局部搜索的方法，但不保证有限步终止。</p>\\n<p>为了刻画Nash平衡和最优解的距离，定义<em>稳定代价</em>（Price of stability）为最优Nash平衡和最优解的比值</p>\\n<h3 id=\\"maximum-leaf-spanning-tree\\">Maximum Leaf Spanning Tree</h3>\\n<p>TODO</p>\\n<p>https://www.cs.cmu.edu/afs/cs/academic/class/15854-f05/www/scribe/lec05.pdf</p>\\n<h3 id=\\"_23\\">其他</h3>\\n<p>N-皇后问题（N×N棋盘中放置N个皇后，其中两两都不在同一行/列/斜线上）局部搜索算法：注意到解为一个排列<script type=\\"math/tex\\">\\\\pi_i \\\\in \\\\{1, 2, ..., N\\\\}<\/script>表示第i行的皇后在第<script type=\\"math/tex\\">\\\\pi_i<\/script>列，这样就只需考虑斜线的冲突了。于是可以每次随机产生一个排列，并遍历每一对i, j，若交换<script type=\\"math/tex\\">\\\\pi_i, \\\\pi_j<\/script>冲突更少，则交换，若遍历完后仍存在冲突，则重新产生一个排列。</p>\\n<p>3-SAT局部搜索算法：TODO</p>\\n<h2 id=\\"_24\\">随机化算法</h2>\\n<p>令最优化问题的最优解为<script type=\\"math/tex\\">C^*<\/script>，随机化算法得到的解为<script type=\\"math/tex\\">C<\/script>，若对任意规模为n的输入都有 <script type=\\"math/tex\\">\\\\max (\\\\frac{C^*}{C}, \\\\frac{C}{C^*})\\\\le \\\\rho(n)<\/script>，则称其为随机化<script type=\\"math/tex\\">\\\\rho(n)<\/script>算法（Randomized <script type=\\"math/tex\\">\\\\rho(n)<\/script>-approximation algorithm）</p>\\n<h3 id=\\"max-3-sat\\">MAX-3-SAT</h3>\\n<p>3-SAT问题的基础上，找到能使最多子句为真的赋值。随机化算法为对每个字进行随机赋值，一半概率为真，一半概率为假，易知每个子句为真的概率为<script type=\\"math/tex\\">X_i \\\\ge 1 - \\\\left(\\\\frac{1}{2}\\\\right)^3 = \\\\frac{7}{8}, \\\\forall i<\/script>，不等是因为子句中可能有互补的字。故真子句个数的期望 <script type=\\"math/tex\\">E\\\\left[\\\\sum_{i=1}^{n} X_i\\\\right]\\\\ge\\\\frac{7n}{8}<\/script>。所以是随机化<script type=\\"math/tex\\">\\\\frac{8}{7}<\/script>近似</p>\\n<h3 id=\\"contention-resolution\\">Contention Resolution</h3>\\n<p>争端解决问题为给定n个进程<script type=\\"math/tex\\">P_1, ..., P_n<\/script>，若在一时刻内有两个或以上进程请求调用数据库，则在那个时刻的所有进程都被锁定，如何调度？限制是进程间不能通信。</p>\\n<p>算法：每个进程在每个时刻都以<script type=\\"math/tex\\">\\\\frac{1}{n}<\/script>的概率请求数据库</p>\\n<p>首先分析可得<script type=\\"math/tex\\">(1-\\\\frac{1}{n})^{n-1}<\/script>在<script type=\\"math/tex\\">(2,+\\\\infin)<\/script>单调递减，端点值分别为<script type=\\"math/tex\\">\\\\frac{1}{2}, \\\\frac{1}{e}<\/script>。而<script type=\\"math/tex\\">(1-\\\\frac{1}{n})^n<\/script>在<script type=\\"math/tex\\">(2, +\\\\infin)<\/script>单调递增，端点值为<script type=\\"math/tex\\">\\\\frac{1}{4}<\/script>和<script type=\\"math/tex\\">\\\\frac{1}{e}<\/script>。</p>\\n<p>令<script type=\\"math/tex\\">S[i, t]<\/script>为进程i在时刻t成功调用数据库，易知<script type=\\"math/tex\\">P\\\\{S[i, t]\\\\} = \\\\frac{1}{n}\\\\left(1-\\\\frac{1}{n}\\\\right)^{n-1}<\/script>，求导分析后可知<script type=\\"math/tex\\">(1-\\\\frac{1}{n})^{n-1}<\/script>在<script type=\\"math/tex\\">[2, +\\\\infin)<\/script>之间单调递减，于是有<script type=\\"math/tex\\">\\\\frac{1}{en}\\\\le P\\\\{S[i, t]\\\\} \\\\le \\\\frac{1}{2n}<\/script>。</p>\\n<p>令<script type=\\"math/tex\\">F[i, \\\\tau]<\/script>为进程i在<script type=\\"math/tex\\">[1, \\\\tau]<\/script>时刻中都没有成功调用数据库，于是<script type=\\"math/tex\\">F[i, \\\\tau] = (1-S[i, t])^\\\\tau \\\\le (1-\\\\frac{1}{en})^{\\\\tau}<\/script>。</p>\\n<p>令<script type=\\"math/tex\\">\\\\tau=en<\/script>，有<script type=\\"math/tex\\">F[i, en] \\\\le (1 - \\\\frac{1}{en})^{en} \\\\le \\\\frac{1}{e}<\/script>，令<script type=\\"math/tex\\">\\\\tau = en c \\\\log n<\/script>，有<script type=\\"math/tex\\">F[i， enc\\\\log n]\\\\le (1-\\\\frac{1}{en})^{enc\\\\log n} = \\\\left[(1-\\\\frac{1}{en})^{en}\\\\right]^{c\\\\log n} \\\\le e^{-c\\\\log n} = n^{-c}<\/script>\\n</p>\\n<p>故令<script type=\\"math/tex\\">\\\\tau_0 = 2en\\\\log n<\/script>可知，在<script type=\\"math/tex\\">[1, \\\\tau_0]<\/script>时刻内至少有一个进程失败的概率为<script type=\\"math/tex\\">\\\\cup_i P[F[i, \\\\tau_0]] \\\\le \\\\sum_i P[F[i, \\\\tau_0]] \\\\le n n^{-2} = \\\\frac{1}{n}<\/script>\\n</p>\\n<h3 id=\\"global-minimum-cut\\">Global Minimum Cut</h3>\\n<p>给定无向图，求其全局最小割（全局是指源和汇可以任意）</p>\\n<p>算法：基于并查集，每次随机选取一条边<script type=\\"math/tex\\">(u, v)<\/script>，合并包含uv的两个连通块，并去除其自环边，直到连通度为2</p>\\n<p><strong>定理</strong>  该算法能求得最小割的概率至少为<script type=\\"math/tex\\">\\\\frac{2}{n(n-1)}<\/script>\\n</p>\\n<p><strong>证明</strong>  令n为原图顶点数，F是全局最小割边集，<script type=\\"math/tex\\">|F|=k<\/script>，<script type=\\"math/tex\\">X_i<\/script>为第i轮循环中选择的边不在F中的事件，令<script type=\\"math/tex\\">V_i, E_i<\/script>分别是第i轮循环中的连通块个数和边数。在第i轮循环中，因为每次循环连通度减一，故有<script type=\\"math/tex\\">|V_i|=n-i<\/script>，又每个连通块的度数至少为k（否则与全局最小割为k矛盾），故<script type=\\"math/tex\\">|E_i|\\\\ge \\\\frac{k|V_i|}{2}<\/script>，所以<script type=\\"math/tex\\">P\\\\{X_i\\\\} = 1-\\\\frac{k}{|E_i|} \\\\ge 1-\\\\frac{2}{n-i}<\/script>。故能求得全局最小割的概率为</p>\\n<p>\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\nP\\\\{success\\\\} &= \\\\prod_i P\\\\{X_i\\\\} \\\\\\\\\\n& \\\\ge \\\\prod_{i=1}^{n-3} P\\\\{X_i\\\\} =\\\\frac{n-3}{n-1}\\\\frac{n-4}{n-2}...\\\\frac{1}{3} = \\\\frac{2}{n(n-1)}\\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<p><strong>推论</strong>  全局最小割数量不超过<script type=\\"math/tex\\">\\\\frac{n(n-1)}{2}<\/script>\\n</p>\\n<p><strong>证明</strong>  令r为全局最小割数量，令<script type=\\"math/tex\\">A_i<\/script>为算法返回第i个最小割的事件，同上类似可证 <script type=\\"math/tex\\">A_i\\\\ge \\\\frac{2}{n(n-1)}<\/script>。因为<script type=\\"math/tex\\">A_i<\/script>之间相互独立，则算法返回任意一个全局最小割的概率为<script type=\\"math/tex\\">P\\\\{\\\\cup_{i=1}^{r} A_i\\\\} = \\\\sum A_i\\\\ge r\\\\frac{2}{n(n-1)}<\/script>，而概率小于1，故<script type=\\"math/tex\\">r\\\\le \\\\frac{n(n-1)}{2}<\/script>\\n</p>\\n<h3 id=\\"load-balancing_1\\">Load Balancing</h3>\\n<h3 id=\\"_25\\">最近点对问题</h3>\\n<p>TODO</p>\\n<h3 id=\\"universal-hashing\\">Universal Hashing</h3>\\n<p>考虑到输入有可能被设计成使得hash表处于最坏情况，我们可以<strong>随机选择hash函数</strong>，来保证对于任意输入，都能得到常数的平均时间</p>\\n<p>key的全集称为<script type=\\"math/tex\\">U<\/script>，hash函数族<script type=\\"math/tex\\">\\\\mathcal H<\/script>\\n</p>\\n<h3 id=\\"perfect-hashing\\">Perfect Hashing</h3>\\n<p>TODO</p>","tags":["greedy","divide-and-conquer","notes"],"title":"算法笔记","updated_at":"2020-07-22T12:51:20+08:00","url":"/docs/course/alg-notes"}')}}]);
//# sourceMappingURL=chunk-2d22669c.6ed645d5.js.map