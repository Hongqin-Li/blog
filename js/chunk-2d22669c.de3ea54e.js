(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d22669c"],{e90b:function(t){t.exports=JSON.parse('{"date":"<built-in method date of datetime.datetime object at 0x7f7cc2d5e030>","html":"<h2 id=\\"dp\\">DP</h2>\\n<p>TODO</p>\\n<h2 id=\\"_1\\">最短路径算法</h2>\\n<p>最长路径不具有最优子结构</p>\\n<h3 id=\\"single-source-shortest-path\\">Single source shortest path</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>适用情况</th>\\n<th>算法</th>\\n<th>复杂度</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>无边权</td>\\n<td>BFS</td>\\n<td>\\n<script type=\\"math/tex\\">O(V+E)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>无负边权</td>\\n<td>Dijkstra</td>\\n<td>\\n<script type=\\"math/tex\\">O(E + V\\\\log V)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>所有情况</td>\\n<td>Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>DAG</td>\\n<td>拓扑排序 + 1 round Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(V+E)<\/script>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\"dijkstra\\">Dijkstra</h4>\\n<p>维护已计算好的最短路径的节点</p>\\n<h4 id=\\"bellman-ford\\">Bellman-Ford</h4>\\n<p>\\n<script type=\\"math/tex\\">\\\\delta(s, v_i) = \\\\delta(s, v_{i-1}) + w(v_{i-1}, v_i)<\/script>\\n</p>\\n<p>算法为两层循环</p>\\n<h4 id=\\"difference-constraint\\">Difference constraint</h4>\\n<p>将差分约束方程转换成图，充要条件</p>\\n<ul>\\n<li>若负环存在，则无解</li>\\n<li>若负环不存在，则有解（证明：加一个到所有节点的s，令<script type=\\"math/tex\\">x_i=\\\\delta(s, v_i)<\/script>即可）</li>\\n</ul>\\n<p>于是可用Bellman-Ford来解决</p>\\n<h3 id=\\"all-pairs-shortest-path\\">All-pairs shortest path</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>适用情况</th>\\n<th>算法</th>\\n<th>复杂度</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>无边权</td>\\n<td>V次BFS</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>无负边权</td>\\n<td>V次Dijkstra</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE + V^2\\\\log V)=O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>所有情况*</td>\\n<td>V次Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(V^2E)<\/script>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>判断负环是否存在的两种方法</p>\\n<ul>\\n<li>通过判断对角线上是否为负（到自己的路径为负，即负环）</li>\\n<li>在运行一轮算法，若边权改变了，则存在负环</li>\\n</ul>\\n<p>*用以下三种方法来优化适用所有情况的多点源最短路算法</p>\\n<h4 id=\\"matrix-multiplication\\">Matrix multiplication</h4>\\n<p>DP方程 <script type=\\"math/tex\\">d_{ij}^{(m)} = \\\\min \\\\{ d_{ik}^{(m-1)} + a_{kj}\\\\}<\/script>\\n</p>\\n<p>看作矩阵乘法 <script type=\\"math/tex\\">D^{(m)} = D^{(m-1)} \\\\otimes A = D^{(0)} \\\\otimes A^{m}<\/script>，<script type=\\"math/tex\\">D^{(0)} = \\\\left[\\\\begin{matrix} 0 & \\\\infin & \\\\infin \\\\\\\\ \\\\infin & ... & \\\\infin \\\\\\\\ \\\\infin & \\\\infin & 0   \\\\end{matrix}\\\\right]<\/script>\\n</p>\\n<p>用divider-and-conquer做幂运算，复杂度为<script type=\\"math/tex\\">O(V^3 \\\\log V)<\/script>\\n</p>\\n<ul>\\n<li>但不能用Strassen</li>\\n</ul>\\n<h4 id=\\"floyd-warshall\\">Floyd-Warshall</h4>\\n<p>DP方程：从i到j的只用到前k个点的最短路径长度 <script type=\\"math/tex\\">d_{ij}^{k} = \\\\min \\\\left\\\\{ d_{ij}^{k-1}, d_{ik}^{k-1} + d_{kj}^{k-1} \\\\right\\\\}<\/script>\\n</p>\\n<p>复杂度<script type=\\"math/tex\\">O(V^3)<\/script>\\n</p>\\n<h4 id=\\"johnsons-algorithm\\">Johnson\'s algorithm</h4>\\n<ol>\\n<li>先将所有边权变成非负，即寻找h 使得 <script type=\\"math/tex\\">w_h(u, v) = w(u, v) + h(u) - h(v) \\\\ge 0<\/script>\\n</li>\\n</ol>\\n<p>这是差分约束问题 <script type=\\"math/tex\\">h(v)- h(u) \\\\le w(u, v)<\/script>，可使用 Bellman-Ford 完成或找到负环</p>\\n<p>复杂为 <script type=\\"math/tex\\">O(VE)<\/script>\\n</p>\\n<ol>\\n<li>再用V次Dijkstra算法找到<script type=\\"math/tex\\">\\\\delta_h(u, v)<\/script>\\n</li>\\n</ol>\\n<p>复杂度为 <script type=\\"math/tex\\">O(VE + V^2\\\\log V)<\/script>\\n</p>\\n<ol>\\n<li>由 <script type=\\"math/tex\\">\\\\delta_h(u, v) = \\\\delta(u, v) + h(u) - h(v)<\/script> 可反推出<script type=\\"math/tex\\">\\\\delta(u, v)<\/script>\\n</li>\\n</ol>\\n<p>复杂度为 <script type=\\"math/tex\\">O(V^2)<\/script>\\n</p>\\n<p>故总复杂度为<script type=\\"math/tex\\">O(VE + V^2\\\\log V)=O(VE)<\/script>\\n</p>\\n<h2 id=\\"_2\\">网络流</h2>\\n<h3 id=\\"_3\\">概念</h3>\\n<ul>\\n<li>\\n<p>流、割（点割集）、割集（边割集）、割(A,B)的容量<script type=\\"math/tex\\">c(A,B)=\\\\sum_\\\\text{e out of A}c_e<\/script>\\n</p>\\n</li>\\n<li>\\n<p>残量网络：为了可以撤销操作</p>\\n</li>\\n<li>\\n<p>最大流、最小割</p>\\n</li>\\n</ul>\\n<h3 id=\\"ford-fulkerson\\">Ford-Fulkerson</h3>\\n<p>不断增广，直到没有增广路为止</p>\\n<p>\\n<script type=\\"math/tex\\">O(|E|max f) <\/script>，f是最大流大小</p>\\n<h3 id=\\"_4\\">预流推进</h3>\\n<p>TODO</p>\\n<h3 id=\\"_5\\">题目</h3>\\n<ul>\\n<li>最小割唯一性，ZOJ 2587</li>\\n<li>平面图最大流</li>\\n<li>超级源和超级汇</li>\\n<li>分点</li>\\n</ul>\\n<h2 id=\\"pnpnpc\\">P/NP/NPC</h2>\\n<ul>\\n<li>P：多项式求解</li>\\n<li>NP：多项式验证</li>\\n<li>NPC：任意一个NP问题都能多项式规约于一个NPC问题</li>\\n</ul>\\n<h3 id=\\"npc\\">NPC</h3>\\n<p>定点覆盖问题：能否找到顶点数大于等于看的顶点覆盖（用顶点覆盖所有边）</p>\\n<p>独立集问题：是否能找到顶点数大于等于k的独立集（所有点互不相连）</p>\\n<p>集合覆盖问题：给定集合的若干个子集，能否用其中的k个子集覆盖原集合</p>\\n<p>3-SAT问题：由n个元素构成的含k个三元子句的合取范式，能否为真？</p>\\n<p>Circuit-SAT</p>\\n<p>哈密顿回路/路径问题：从3-SAT的规约（欧拉回路/路径属于P）</p>\\n<p>TSP问题：从哈密顿回路规约</p>\\n<p>3DM：从3-SAT规约</p>\\n<p>子集和问题：从3-SAT规约</p>\\n<p>划分问题：从子集和问题规约</p>\\n<p>顶点覆盖和独立集等价</p>\\n<p>\\n<script type=\\"math/tex\\">\\\\text{Vertex Cover}\\\\le_p\\\\text{Set Cover}<\/script>\\n</p>\\n<p>\\n<script type=\\"math/tex\\">\\\\text{3-SAT}\\\\le_p \\\\text{Set Cover}<\/script>\\n</p>\\n<h2 id=\\"_6\\">近似算法</h2>\\n<p>Load Balancing</p>\\n<p>Center Selection</p>\\n<p>集合覆盖：logn近似</p>\\n<p>顶点覆盖</p>","last_modified":"2020-06-09 05:25:16.202941","tags":["algorithm","notes"],"title":"算法笔记"}')}}]);
//# sourceMappingURL=chunk-2d22669c.de3ea54e.js.map