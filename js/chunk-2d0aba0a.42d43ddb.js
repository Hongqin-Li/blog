(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0aba0a"],{"15a1":function(t){t.exports=JSON.parse('{"created_at":"2020-10-17T12:00:02+08:00","excerpt":"半群：运算满足结合律和封闭性","html":"<h2 id=\\"_1\\">群论</h2>\\n<p>半群：运算满足结合律和封闭性</p>\\n<p>幺半群：含单位元的半群</p>\\n<p>群：每个元素均存在逆元的幺半群</p>\\n<p>等价关系：满足自反性、对称性、传递性的二元运算</p>\\n<h3 id=\\"_2\\">陪集分解</h3>\\n<p><strong>引理 1</strong>    <script type=\\"math/tex\\">G<\/script> 是群，<script type=\\"math/tex\\">A<\/script> 是 <script type=\\"math/tex\\">G<\/script> 的子群，则对 <script type=\\"math/tex\\">\\\\forall g, h\\\\in G<\/script>，定义关系 <script type=\\"math/tex\\">g\\\\sim h \\\\iff gh^{-1}\\\\in A<\/script> 为等价关系，且 <script type=\\"math/tex\\">g<\/script> 的等价类为 <script type=\\"math/tex\\">Ag<\/script>．</p>\\n<p>此时每个等价类称为 <script type=\\"math/tex\\">G<\/script> 对于子群 A 的<strong>右陪集</strong>，类似可定义左陪集．显然 <script type=\\"math/tex\\">G<\/script> 可由一些互不相交的右陪集组成，即 <script type=\\"math/tex\\">G = \\\\bigcup_{g\\\\in R} Ag<\/script>，其中 <script type=\\"math/tex\\">R<\/script> 称为<strong>右陪集代表元系</strong>，并令 <script type=\\"math/tex\\">[G:A]=|R|<\/script>，于是有 <script type=\\"math/tex\\">|G|=|A|\\\\cdot [G:A]<\/script>．易得下述定理．</p>\\n<p><strong>定理 1</strong>    群<script type=\\"math/tex\\">G<\/script> 的子群的阶一定是 <script type=\\"math/tex\\">|G|<\/script> 的因子．</p>\\n<p><strong>定理 2</strong>    有限群 <script type=\\"math/tex\\">G<\/script> 中任意元素的阶必是 <script type=\\"math/tex\\">|G|<\/script> 的因子．</p>\\n<p><strong>定理 3</strong>    设 <script type=\\"math/tex\\">g, h<\/script> 是群 <script type=\\"math/tex\\">G<\/script> 中元素，若 <script type=\\"math/tex\\">g<\/script> 的阶为 <script type=\\"math/tex\\">n<\/script>，则对每个正整数 <script type=\\"math/tex\\">i<\/script>，<script type=\\"math/tex\\">g^i<\/script> 的阶是 <script type=\\"math/tex\\">\\\\frac{n}{(n, i)}<\/script>；若 <script type=\\"math/tex\\">gh=hg<\/script>，<script type=\\"math/tex\\">g, h<\/script> 的阶分别为 <script type=\\"math/tex\\">n, m<\/script>，且 <script type=\\"math/tex\\">(n, m)=1<\/script>，则 <script type=\\"math/tex\\">gh<\/script> 的阶为 <script type=\\"math/tex\\">nm<\/script>．</p>\\n<p><strong>定理 4</strong>    <script type=\\"math/tex\\">A, B<\/script> 为有限群 <script type=\\"math/tex\\">G<\/script> 的子集，则</p>\\n<ol>\\n<li>\\n<script type=\\"math/tex\\">|AB|=|A|\\\\cdot |B|/|A\\\\cap B|<\/script>；</li>\\n<li>若 <script type=\\"math/tex\\">A<\/script> 是 <script type=\\"math/tex\\">B<\/script> 的子集，则 <script type=\\"math/tex\\">[G:A]=[G:B][B:A]<\/script>；</li>\\n<li>\\n<script type=\\"math/tex\\">[G:A\\\\cap B]\\\\le [G:A][G:B]<\/script>，进而若 <script type=\\"math/tex\\">[G:A]<\/script> 和 <script type=\\"math/tex\\">[G:B]<\/script> 互素，则 <script type=\\"math/tex\\">[G:A\\\\cap B]=[G:A][G:B]<\/script> 且 <script type=\\"math/tex\\">AB=G<\/script>．</li>\\n</ol>\\n<p><strong>证明</strong>    TODO</p>\\n<p>定义</p>\\n<p>习题：</p>\\n<ol>\\n<li>若群 <script type=\\"math/tex\\">G<\/script> 中除单位元外每个元素的阶均为 <script type=\\"math/tex\\">2<\/script>，则 <script type=\\"math/tex\\">G<\/script> 为可交换群．</li>\\n<li>\\n<script type=\\"math/tex\\">p<\/script>（素数）阶群均是可交换群，且均同构于整数模 <script type=\\"math/tex\\">p<\/script> 加法群 <script type=\\"math/tex\\">Z_p<\/script>．</li>\\n<li>非交换的群的最小阶为 <script type=\\"math/tex\\">6<\/script>．</li>\\n<li>加法循环群 <script type=\\"math/tex\\">G = \\\\left\\\\{ka \\\\bmod b \\\\mid \\\\forall k\\\\right\\\\}<\/script> 的元素个数为 <script type=\\"math/tex\\">\\\\frac{b}{gcd(a, b)}<\/script>．</li>\\n<li>素数阶群一定是循环群．</li>\\n</ol>\\n<h3 id=\\"_3\\">循环群</h3>\\n<p><strong>定理</strong>    在 <script type=\\"math/tex\\">n<\/script> 阶循环群 <script type=\\"math/tex\\">G<\/script> 中，对 <script type=\\"math/tex\\">n<\/script> 的每个正因子 <script type=\\"math/tex\\">m<\/script>，阶为 <script type=\\"math/tex\\">m<\/script> 的元素恰好有 <script type=\\"math/tex\\">\\\\varphi(m)<\/script> 个，由此证明等式 <script type=\\"math/tex\\">\\\\sum_{m|n} \\\\varphi(m) = n<\/script>．</p>\\n<p><strong>证明</strong>    由于 <script type=\\"math/tex\\">g^i<\/script> 的阶为 <script type=\\"math/tex\\">\\\\frac{n}{gcd(n, i)}=m<\/script>，于是 <script type=\\"math/tex\\">i<\/script> 只能是 <script type=\\"math/tex\\">1\\\\frac{n}{m}, ..., m\\\\frac{n}{m}<\/script> 中系数与 <script type=\\"math/tex\\">m<\/script> 互质的数，即有 <script type=\\"math/tex\\">\\\\varphi(m)<\/script> 个．</p>\\n<p><strong>定理</strong>    循环群 <script type=\\"math/tex\\">G<\/script> 的子群的阶互不相等，即每种阶数的子群至多只有一个</p>\\n<p><strong>证明</strong>    阶为 <script type=\\"math/tex\\">d<\/script> 的子群必为 <script type=\\"math/tex\\">\\\\left\\\\{\\\\left(a^{\\\\frac{n}{d}}\\\\right)^i\\\\right\\\\}<\/script>\\n</p>\\n<p>习题：</p>\\n<ol>\\n<li>若 <script type=\\"math/tex\\">G<\/script> 是循环群，则其任意子群均是循环群，且若 <script type=\\"math/tex\\">r<\/script> 是 <script type=\\"math/tex\\">|G|<\/script> 的因子，则 <script type=\\"math/tex\\">G<\/script> 有且仅有一个 <script type=\\"math/tex\\">r<\/script> 阶子群．</li>\\n</ol>\\n<h2 id=\\"_4\\">数论</h2>\\n<h3 id=\\"_5\\">符号说明</h3>\\n<p>令 <script type=\\"math/tex\\">(a, b)=gcd(a, b)<\/script>，<script type=\\"math/tex\\">[a, b]=lcm(a, b)<\/script>\\n</p>\\n<h3 id=\\"_6\\">质因数分解</h3>\\n<p>定理：任意正整数 <script type=\\"math/tex\\">a<\/script>，总能唯一的分解成质因子幂次的乘积，即 <script type=\\"math/tex\\">a =\\\\prod p_i^{a_i}<\/script>\\n</p>\\n<p>证明：TODO</p>\\n<p>易证如下结论</p>\\n<ul>\\n<li>\\n<script type=\\"math/tex\\">a\\\\mid b \\\\iff a_i\\\\le b_i<\/script>\\n</li>\\n<li>\\n<script type=\\"math/tex\\">(a, b)_i = \\\\min\\\\{a_i, b_i\\\\}<\/script>，推论 <script type=\\"math/tex\\">(a, b)=1 \\\\iff a_i b_i = 0<\/script>\\n</li>\\n<li>\\n<script type=\\"math/tex\\">[a, b]_i=\\\\max\\\\{a_i, b_i\\\\}<\/script>\\n</li>\\n</ul>\\n<p>例 1：<script type=\\"math/tex\\">x\\\\mid a, x\\\\mid b\\\\iff x \\\\mid (a, b)<\/script>\\n</p>\\n<p>证：充分性显然，必要性由 <script type=\\"math/tex\\">(a,b)_i = \\\\min\\\\{a_i, b_i\\\\}<\/script> 且 <script type=\\"math/tex\\">x_i\\\\le a_i, b_i<\/script>，故有 <script type=\\"math/tex\\">x_i\\\\le gcd_i<\/script>，即 <script type=\\"math/tex\\">x\\\\mid (a, b)<\/script>．</p>\\n<p>例 2：<script type=\\"math/tex\\">(a, m)=(b, m)=1\\\\iff (ab, m)=1<\/script>\\n</p>\\n<p>例 3：若 <script type=\\"math/tex\\">c\\\\mid ab<\/script> 且 <script type=\\"math/tex\\">(c, a)=1<\/script>，则 <script type=\\"math/tex\\">c|b<\/script>\\n</p>\\n<p>例 4：<script type=\\"math/tex\\">(x, [a, b])=[(x, a), (x, b)]<\/script>\\n</p>\\n<h3 id=\\"gcd\\">GCD</h3>\\n<h4 id=\\"_7\\">欧几里得算法</h4>\\n<p>易证 <script type=\\"math/tex\\">gcd(a, b)\\\\iff gcd(b-ka, a) \\\\iff gcd(b\\\\mod a, a)<\/script>\\n</p>\\n<p>算法复杂度 <script type=\\"math/tex\\">O(\\\\log n)<\/script>\\n</p>\\n<p>证明：不妨设 <script type=\\"math/tex\\">a<b<\/script>，考虑两轮过后 <script type=\\"math/tex\\">gcd(a, b) = gcd(b\\\\%a, a)=gcd(a\\\\%(b\\\\%a), a)<\/script>，<script type=\\"math/tex\\">a<\/script> 变成了 <script type=\\"math/tex\\">a\\\\%(b%a)<\/script>，如下暴力观察一下，可以发现这个过程中 <script type=\\"math/tex\\">a<\/script> 至少减半\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\na\\\\%(b\\\\%a) = \\\\begin{cases}\\na \\\\% (a-1) = \\\\min\\\\{1, a-2\\\\}, &\\\\text{if }b\\\\% a =a-1 \\\\\\\\\\na \\\\% (a-2) = \\\\min\\\\{2, a-3\\\\}, &\\\\text{if }b\\\\% a =a-2 \\\\\\\\\\n... \\\\\\\\\\na \\\\% (a-(a-1)) = \\\\min\\\\{a-1, 0\\\\}, &\\\\text{if }b\\\\% a =1 \\\\\\\\\\n\\\\end{cases}\\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<h4 id=\\"_8\\">扩展欧几里得算法</h4>\\n<p>假设我们已知 <script type=\\"math/tex\\">gcd(b\\\\bmod a, a)=(b\\\\bmod a) x\' + ay\'=(b-\\\\lfloor\\\\frac{b}{a}\\\\rfloor a) x\' + ay\'<\/script> 中的 <script type=\\"math/tex\\">x\',y\'<\/script>，则我们可以求出满足 <script type=\\"math/tex\\">ax+by=gcd(a, b)<\/script> 的 <script type=\\"math/tex\\">x, y<\/script>\\n</p>\\n<p>证明：由欧几里得算法知上两式相等，移相整理后可得 <script type=\\"math/tex\\">x=y\'-a\\\\lfloor\\\\frac{b}{a}\\\\rfloor, y=x\'<\/script>\\n</p>\\n<h4 id=\\"_9\\">裴蜀定理</h4>\\n<p>设<script type=\\"math/tex\\">a, b\\\\in Z<\/script>，则存在<script type=\\"math/tex\\">x, y\\\\in Z<\/script>，使得 <script type=\\"math/tex\\">ax+by = gcd(a, b)<\/script>\\n</p>\\n<p>证明：由扩展欧几里得算法直接得到</p>\\n<p>推论：对任意 <script type=\\"math/tex\\">k\\\\in Z<\/script>，均存在 <script type=\\"math/tex\\">x, y\\\\in Z<\/script>，使得 <script type=\\"math/tex\\">gcd(a, b)\\\\mid (ax+by)<\/script>，且 <script type=\\"math/tex\\">|ax+by|<\/script> 的最小非零值为 <script type=\\"math/tex\\">gcd(a, b)<\/script>\\n</p>\\n<p>证明：前半句由裴蜀定理直接得到，后半句则因为 <script type=\\"math/tex\\">ax+by = \\\\lambda_a gcd(a, b) \\\\cdot x + \\\\lambda_b gcd(a, b)\\\\cdot y =(\\\\lambda_a x + \\\\lambda_b y)\\\\cdot gcd(a, b)<\/script>，即总是 <script type=\\"math/tex\\">gcd(a, b)<\/script> 的倍数</p>\\n<h3 id=\\"_10\\">欧拉函数与欧拉定理</h3>\\n<h4 id=\\"_11\\">欧拉函数</h4>\\n<p>欧拉函数：<script type=\\"math/tex\\">\\\\varphi(n)<\/script> 代表「小于 <script type=\\"math/tex\\">n<\/script> 的正整数中和 <script type=\\"math/tex\\">n<\/script> 互质的数」的个数</p>\\n<p><strong>定理</strong>    若 <script type=\\"math/tex\\">(m, n)=1<\/script>，则 <script type=\\"math/tex\\">\\\\varphi(mn)=\\\\varphi(m)\\\\varphi(n)<\/script>\\n</p>\\n<p><strong>证明</strong>    令所有小于 <script type=\\"math/tex\\">m<\/script> 且与 <script type=\\"math/tex\\">m<\/script> 互质的正整数组成的集合为 <script type=\\"math/tex\\">\\\\Phi(m)<\/script>，也称为<strong>最小正缩剩余系（Least Positive Reduced residue system）</strong>，定义如下函数\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}f:\\\\Phi(m)\\\\times \\\\Phi(n) &\\\\to \\\\Phi(mn) \\\\\\\\(r, s)&\\\\mapsto syn+rxm \\\\bmod mn\\\\\\\\\\\\end{aligned}\\n<\/script>\\n其中<script type=\\"math/tex\\">x, y<\/script> 满足 <script type=\\"math/tex\\">xm+ yn=1<\/script>（裴蜀定理）。易证此函数是双射的，而显然 <script type=\\"math/tex\\">\\\\varphi(x)=|\\\\Phi(x)|<\/script>，于是 <script type=\\"math/tex\\">\\\\varphi(mn) =\\\\varphi(m)\\\\varphi(n)<\/script>\\n</p>\\n<p><strong>推论</strong>    <script type=\\"math/tex\\">\\\\varphi(n) = n \\\\prod\\\\limits_{p\\\\mid n} \\\\left(1-\\\\frac{1}{p}\\\\right)<\/script>，其中 <script type=\\"math/tex\\">p<\/script> 为质数</p>\\n<p><strong>证明</strong>    易知若 <script type=\\"math/tex\\">p<\/script> 为质数，则 <script type=\\"math/tex\\">\\\\varphi(p^k)=p^k-p^{k-1}<\/script>，再结合上述定理质因子分解一下即可。也可以由<a href=\\"#循环群\\">循环群的性质</a>直接证明。</p>\\n<h4 id=\\"_12\\">欧拉定理</h4>\\n<p>引理：若 <script type=\\"math/tex\\">ac \\\\equiv bc \\\\bmod m<\/script>，则 <script type=\\"math/tex\\">a \\\\equiv b \\\\bmod \\\\frac{m}{gcd(m, c)}<\/script>\\n</p>\\n<p>证明：由第一式得 <script type=\\"math/tex\\">ac-bc=km<\/script>，两边同除 <script type=\\"math/tex\\">gcd(m, c)<\/script> 得 <script type=\\"math/tex\\">a\\\\lambda_c - b \\\\lambda_c = k \\\\lambda_m<\/script>，其中 <script type=\\"math/tex\\">\\\\lambda_c, \\\\lambda_m<\/script> 互质，于是 <script type=\\"math/tex\\">k<\/script> 中必含有 <script type=\\"math/tex\\">\\\\lambda_c<\/script>，再两边同除 <script type=\\"math/tex\\">\\\\lambda_c<\/script> 即可证明</p>\\n<p>定理：若 <script type=\\"math/tex\\">a,m<\/script> 互质，则 <script type=\\"math/tex\\">a^{\\\\varphi(m)} \\\\equiv 1\\\\bmod m<\/script>\\n</p>\\n<p>证明：令 <script type=\\"math/tex\\">x_1, ..., x_{\\\\varphi(m)}<\/script> 为与 <script type=\\"math/tex\\">m<\/script> 互质的数，易证 <script type=\\"math/tex\\">\\\\{x_i | i = 1, ..., \\\\varphi(m)\\\\}= \\\\{a\\\\cdot x_i\\\\bmod m \\\\mid i = 1, ..., \\\\varphi(m)\\\\}<\/script>，连乘起来可得 <script type=\\"math/tex\\">\\\\prod x_i \\\\equiv a^{\\\\varphi(m)}\\\\prod x_i \\\\bmod m<\/script>，由引理知 <script type=\\"math/tex\\">a^{\\\\varphi(m)}\\\\equiv 1 \\\\bmod m<\/script>\\n</p>\\n<p>例：求正整数 <script type=\\"math/tex\\">3^{83}<\/script> 的最后两位数，显然模 <script type=\\"math/tex\\">100<\/script> 即可</p>\\n<h4 id=\\"_13\\">费马小定理</h4>\\n<p>若 <script type=\\"math/tex\\">p<\/script> 为素数，则对任意整数 <script type=\\"math/tex\\">a<\/script> 有 <script type=\\"math/tex\\">a^{p-1} \\\\equiv 1 \\\\bmod p<\/script>\\n</p>\\n<p>证明：欧拉定理中令 <script type=\\"math/tex\\">m<\/script> 为素数可得</p>\\n<h4 id=\\"_14\\">扩展欧拉定理</h4>\\n<p>$$\\na^b = \\\\begin{cases}</p>\\n<p>\\\\end{cases}\\n$$</p>\\n<h3 id=\\"_15\\">线性同余方程</h3>\\n<p>如何求线性同余方程 <script type=\\"math/tex\\">ax\\\\equiv c \\\\bmod b<\/script> 的解？</p>\\n<p>显然，这等价于求解 <script type=\\"math/tex\\">ax + by = c<\/script>，而由裴蜀定理一节，解存在当且仅当 <script type=\\"math/tex\\">c \\\\mid gcd(a, b)<\/script>。若有解，可用扩展欧几里得算法得到一组解 <script type=\\"math/tex\\">x_0, y_0<\/script>，至于如何求出其他所有解，假设存在另外一组解 <script type=\\"math/tex\\">x_1, y_1<\/script>，则有\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\n\\\\because a(x_0 - x_1) +b(y_0-y_1) = c \\\\\\\\\\n\\\\therefore a \\\\Delta x + b \\\\Delta y = 0\\\\\\\\\\n\\\\therefore \\\\Delta y = -\\\\frac{a}{b} \\\\Delta x = \\\\frac{\\\\lambda_a}{\\\\lambda_b}\\\\Delta x\\n\\\\end{aligned}\\n<\/script>\\n两边同除 <script type=\\"math/tex\\">gcd(a, b)<\/script> 可得最后一个等号，又因为 <script type=\\"math/tex\\">\\\\Delta x,\\\\Delta y\\\\in Z<\/script>，于是有 <script type=\\"math/tex\\">\\\\Delta x = k\\\\lambda_b, \\\\Delta y = -k\\\\lambda_a, \\\\forall k\\\\in Z<\/script>，即得到了通解的表达式。</p>\\n<h3 id=\\"_16\\">中国剩余定理</h3>\\n<p>定理：同余方程组 <script type=\\"math/tex\\">x\\\\equiv a_i\\\\bmod m_i(i=1, ..., n)<\/script> 有解的充要条件是\\n<script type=\\"math/tex; mode=display\\">\\na_i \\\\equiv a_j \\\\bmod (m_i, m_j), i = 1, ..., n\\n<\/script>\\n证明：对 <script type=\\"math/tex\\">n<\/script> 用数学归纳法。</p>\\n<p>当 <script type=\\"math/tex\\">n=2<\/script> 时，<script type=\\"math/tex\\">x=a_1+k_1 m_1=a_2+k_2 m_2<\/script>，再由裴蜀定理可证。</p>\\n<p>假设当 <script type=\\"math/tex\\">n\\\\le k<\/script> 时结论成立，考虑当 <script type=\\"math/tex\\">n=k+1<\/script>。必要性可由 <script type=\\"math/tex\\">n=2<\/script> 的情况直接得到，下证充分性。</p>\\n<p>先考虑最后两个方程，由归纳假设知存在解 <script type=\\"math/tex\\">b<\/script> 使得 <script type=\\"math/tex\\">b\\\\equiv a_k\\\\bmod m_k<\/script> 且 <script type=\\"math/tex\\">b\\\\equiv a_{k+1}\\\\bmod m_{k+1}<\/script>，于是有 <script type=\\"math/tex\\">x\\\\equiv b \\\\bmod [m_k, m_{k+1}]<\/script>。易证，可将这两个方程合并成一个 <script type=\\"math/tex\\">x\\\\equiv b \\\\bmod [m_k, m_{k+1}]<\/script>，于是只需证如下\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\n&a_i \\\\equiv b \\\\bmod (m_i, [m_k, m_{k+1}]), i = 1, ..., k-1\\\\\\\\\\n\\\\iff &a_i \\\\equiv b \\\\bmod [(m_i, m_k), (m_i, m_{k+1})] \\\\\\\\\\n\\\\impliedby &a_i \\\\equiv b \\\\bmod (m_i, m_k) \\\\,\\\\text{ and }\\\\, a_i \\\\equiv b \\\\bmod (m_i, m_{k+1}) \\n\\\\end{aligned}\\n<\/script>\\n又因为 <script type=\\"math/tex\\">b\\\\equiv a_k \\\\bmod m_k<\/script> 且 <script type=\\"math/tex\\">a_i \\\\equiv a_k \\\\bmod (a_i, a_k)<\/script>（充分条件），故有最后一行中的第一项 <script type=\\"math/tex\\">a_i\\\\equiv b \\\\bmod (m_i, m_k)<\/script>，同理可得第二项，于是假设成立，证毕．（上述推导过程中用到的一些关于 gcd/lcm 的小定理可以自行证明一下）</p>\\n<p>注意到证明过程同时给出了求解过程，即每次取出两个方程求解（扩展欧几里得算法）、合并成一个，然后递归求解．</p>\\n<p>众所周知的<strong>中国剩余定理（Chinese Remainder Theorem）</strong>就是上述定理中模数互质的特例。不过我们可以直接写出表达式，令 <script type=\\"math/tex\\">M_i = \\\\frac{\\\\prod m_k}{m_i}<\/script>，<script type=\\"math/tex\\">y_i = M_i^{-1}\\\\bmod m_i<\/script>（注意到 <script type=\\"math/tex\\">(M_i, m_i)=1<\/script>，故逆元必存在），此时通解为 <script type=\\"math/tex\\">x=\\\\sum a_i M_i y_i + k[m_1, ..., m_n],\\\\forall k\\\\in Z<\/script>\\n</p>\\n<p>例：证明 <script type=\\"math/tex\\">\\\\sum_{i=1}^{2016} i^{2016} \\\\equiv 48 \\\\bmod 2016<\/script>\\n</p>\\n<h3 id=\\"lucas\\">Lucas 定理</h3>\\n<p>TODO</p>\\n<h3 id=\\"_17\\">原根</h3>\\n<p>由裴蜀定理，<script type=\\"math/tex\\">\\\\exists d\\\\in N, a^d\\\\equiv 1\\\\bmod m\\\\iff (a, m)=1<\/script>，称 <script type=\\"math/tex\\">d<\/script> 为 <script type=\\"math/tex\\">a<\/script> 模 <script type=\\"math/tex\\">m<\/script> 的阶</p>\\n<p>考虑模 <script type=\\"math/tex\\">m<\/script> 的既约剩余系 <script type=\\"math/tex\\">G=\\\\{x\\\\mid(x, m)=1, x\\\\in [0, m)\\\\}<\/script>，即所有小于 <script type=\\"math/tex\\">m<\/script> 且与 <script type=\\"math/tex\\">m<\/script> 互质的正整数，显然 <script type=\\"math/tex\\">|G|=\\\\varphi(m)<\/script>。其生成元称为 <script type=\\"math/tex\\">m<\/script> 的原根（原根有可能不存在）</p>\\n<p>定理：若 <script type=\\"math/tex\\">m<\/script> 存在原根，则 <script type=\\"math/tex\\">m<\/script> 一定是下列形式 <script type=\\"math/tex\\">2, 4, p^k, 2p^k<\/script>，其中 <script type=\\"math/tex\\">p<\/script> 为奇素数</p>\\n<p>TODO</p>\\n<h3 id=\\"_18\\">二次剩余</h3>\\n<p><strong>定义</strong>    </p>\\n<h3 id=\\"_19\\">数论函数与积性函数</h3>\\n<p><strong>定义</strong>    定义域为正整数（值域通常为复数）的函数 <script type=\\"math/tex\\">f: N \\\\to C<\/script> 称为<strong>数论函数（Number Theoretic Function）</strong>．</p>\\n<p><strong>定义</strong>    若数论函数 <script type=\\"math/tex\\">f<\/script> 满足，对任意互质的 <script type=\\"math/tex\\">m,n<\/script> 有 <script type=\\"math/tex\\">f(mn)=f(m)f(n)<\/script>，则称为<strong>积性函数（Multiplicative  Function）</strong>．</p>\\n<p><strong>定理</strong>    若<script type=\\"math/tex\\">f<\/script> 是积性函数，则 <script type=\\"math/tex\\">F(n)=\\\\sum_{d|n} f(d)<\/script> 也是积性函数．</p>\\n<h3 id=\\"_20\\">莫比乌斯反演</h3>\\n<p><strong>定义</strong>    <script type=\\"math/tex\\">\\\\mu(n)<\/script>\\n</p>\\n<p><strong>定理</strong>    <script type=\\"math/tex\\">F(n), f(n)<\/script> 是定义在非负整数集合上的函数，且满足 <script type=\\"math/tex\\">F(n)=\\\\sum_{d|n} f(d)<\/script>，则 <script type=\\"math/tex\\">f(n)=\\\\sum_{d|n} \\\\mu(d) F(\\\\frac{n}{d})<\/script>\\n</p>\\n<p><strong>证明</strong></p>\\n<p>Pocklington 定理</p>\\n<h3 id=\\"_21\\">代码实现</h3>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre>1\\n2\\n3</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"kt\\">int</span> <span class=\\"nf\\">gcd</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span> <span class=\\"n\\">a</span><span class=\\"p\\">,</span> <span class=\\"kt\\">int</span> <span class=\\"n\\">b</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span>\\n    <span class=\\"k\\">return</span> <span class=\\"n\\">a</span> <span class=\\"o\\">?</span> <span class=\\"n\\">gcd</span><span class=\\"p\\">(</span><span class=\\"n\\">b</span><span class=\\"o\\">%</span><span class=\\"n\\">a</span><span class=\\"p\\">,</span> <span class=\\"n\\">a</span><span class=\\"p\\">)</span><span class=\\"o\\">:</span> <span class=\\"n\\">b</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h2 id=\\"_22\\">多项式</h2>\\n<p>秦九韶算法（Horner法则）\\n<script type=\\"math/tex; mode=display\\">\\n\\\\begin{aligned}\\nA(x) &= \\\\sum_{i=0}^{n-1} a_i x^i \\\\\\\\\\n&= a_0 + x(\\\\sum_{i=0}^{n-2} a_{i+1} x^i) \\\\\\\\\\n&= a_0 + \\\\left(a_1 + ...\\\\left(a_{n-2} + a_{n-1}x\\\\right)...\\\\right)x\\n\\\\end{aligned}\\n<\/script>\\n</p>\\n<p>定理（代数基本定理）非零n次多项式恰有n个根（含重根）</p>\\n<p>证明</p>\\n<p>定理（多项式插值的唯一性）  任意n个x坐标不同的点<script type=\\"math/tex\\">(x_i, y_i), i=1, ..., n<\/script>，可唯一确定一个n-1次多项式</p>\\n<p>证明  假设存在两个包含这n个点的n-1次多项式p(x)和q(x)，则他们的差<script type=\\"math/tex\\">r(x)=p(x)-q(x)<\/script>为至多n-1次多项式。因为<script type=\\"math/tex\\">r(x_i) = y_i-y_i = 0<\/script>，故n-1次多项式<script type=\\"math/tex\\">r(x)<\/script>有n个不同根，故<script type=\\"math/tex\\">r(x)=0<\/script>。</p>","tags":[{"name":"math","url":"/tags/math"},{"name":"notes","url":"/tags/notes"}],"title":"代数笔记","updated_at":"2020-10-17T12:00:02+08:00","url":"/docs/course/number-theory"}')}}]);
//# sourceMappingURL=chunk-2d0aba0a.42d43ddb.js.map