(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0dd490"],{8178:function(n){n.exports=JSON.parse('{"excerpt":"考试题型：","html":"<p>考试题型：</p>\\n<ul>\\n<li>选择题：</li>\\n<li>操作符重载（Overload）、函数覆盖（Override）、函数隐藏（Hiding）</li>\\n<li>填空题，填3行代码s</li>\\n<li>注意初始化</li>\\n<li>看代码写输出</li>\\n<li>编程题，两道大题</li>\\n<li>重载：操作符（二元/一元）、输入输出，二元操作建议定义在类外，如需访问私有成员，则在类内定义为friend\\n    <code>c++\\n    class T {\\n    public:\\n      friend T operator+(const T&amp;lhs, const T&amp; rhs)) const;\\n      friend istream&amp; operator&gt;&gt;(istream &amp;is, const T&amp; xx);\\n    }</code></li>\\n<li>C++文件操作，split的实现</li>\\n<li>尽可能地用const修饰</li>\\n<li>资源类需要移动赋值操作符号、移动构造函数、拷贝赋值操作符、拷贝构造函数</li>\\n<li><code>#ifdef</code>，<code>#include</code>相关头文件，<code>using namespace std;</code></li>\\n<li>stl中vector, list的使用</li>\\n</ul>\\n<h2 id=\\"_1\\">基础</h2>\\n<p>形式参数（形参）：定义函数时函数名后括号中的变量名\\n实际参数（实参）：调用函数时函数名后括号中的表达式</p>\\n<h3 id=\\"_2\\">静态局部变量</h3>\\n<p>C++中的静态局部变量</p>\\n<ul>\\n<li>内存分配在编译完成（同C）</li>\\n<li>初次执行时会调用构造函数（初始化），之后不再调用（通过某个bit来判断是否是第一次），故若函数未被执行，则不会初始化</li>\\n<li>main之后会调用析构函数</li>\\n</ul>\\n<h3 id=\\"_3\\">引用</h3>\\n<p>引用/指针和常引用/指针的区别和写法</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;iostream&gt;\\n#include &lt;cassert&gt;\\nusing namespace std;\\n\\nint main() {\\n  int a = 1, b = 1;\\n\\n  // error: \'r\' declared as reference but not initialized \\n  // int&amp; r;\\n\\n  // error: cannot bind non-const lvalue reference of type \\n  // \'int&amp;\' to an rvalue of type \'int\'\\n  // int&amp; r = 1;\\n\\n  int&amp; lr = a;\\n  int&amp;&amp; rr = 1 + 1, rr2 = 1+1;\\n  rr += 1;\\n  assert(&amp;rr != &amp;lr &amp;&amp; rr != lr);\\n\\n  // Reference to constant\\n  const int&amp; lrk = lr;\\n  // error: assignment of read-only reference \'lrk\'\\n  // lrk += 1;\\n\\n  // Reference cannot be const\\n  // error: \'const\' qualifiers cannot be applied to \'int&amp;\'\\n  // int &amp; const klr = lr;\\n\\n  // Constant pointer\\n  int * const kptr = &amp;a;\\n  // error: assignment of read-only variable \'kptr\'\\n  // kptr = &amp;b; \\n\\n  // Pointer to const\\n  const int *ptrk = &amp;a;\\n  ptrk = &amp;b;\\n  // error: assignment of read-only location \'* ptrk\'\\n  // *ptrk = 1;\\n\\n  return 0;\\n}</code></pre>\\n\\n\\n<h2 id=\\"stl\\">STL</h2>\\n<h3 id=\\"_4\\">字符串处理</h3>\\n<p>字符串转换到double或int：<code>double atof (const char* str);</code> 和 <code>int atoi (const char * str);</code></p>\\n<p>子串：<code>string string::substr(iterator, len)</code></p>\\n<h3 id=\\"_5\\">算法</h3>\\n<p>TODO</p>\\n<p>sort(a.begin(), a.end())</p>\\n<p>upperbound</p>\\n<p>lowerbound</p>\\n<h3 id=\\"_6\\">输入输出和文件</h3>\\n<p><a href=\\"http://www.cplusplus.com/reference/fstream/fstream/open/\\">打开文件</a>：读（in）、写（out）、二进制模式（binary）、指针移至文件尾（ate）、追加写（app）、从头写（trunc）</p>\\n<p>内容读取：读取一行（<code>stream&amp; getline(char* s [, streamsize n [, char delim]]);</code>）、读取一个字符（get）、撤回读取字符（unget）</p>\\n<p>例子</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;fstream&gt;\\n#include &lt;cstring&gt;\\n#include &lt;iostream&gt;\\n\\nusing namespace std;\\n\\nstring getline(istream &amp;is) {\\n  char c;\\n  string line;\\n  do {\\n    c = is.get();\\n    if (c != EOF) line.push_back(c);\\n  } while (c != \'\\\\n\' &amp;&amp; c != EOF);\\n  return line;\\n}\\n\\nint getint(istream &amp;is) {\\n  char c;\\n  while ((c = is.get()) != EOF &amp;&amp; (c == \' \' || c == \'\\\\n\')) ;\\n  int x = 0;\\n  for (; \'0\' &lt;= c &amp;&amp; c &lt;= \'9\'; c = is.get()) {\\n    x *= 10;\\n    x += c-\'0\';\\n  }\\n  if (c != EOF) is.unget();\\n  return x;\\n}\\n\\nint main() {\\n  fstream fs;\\n  fs.open(&quot;tmp&quot;, fstream::in);\\n  if (!fs) cerr &lt;&lt; &quot;Can\'t open input file!&quot;;\\n  cout &lt;&lt; getint(fs) &lt;&lt; endl;\\n  for (string line = getline(fs); line.size() &gt; 0; line = getline(fs)) {\\n    cout &lt;&lt; line;\\n  }\\n  fs.close();\\n  return 0;\\n}</code></pre>\\n\\n\\n<h2 id=\\"_7\\">类</h2>\\n<ul>\\n<li>默认构造函数：没有参数的构造函数，默认生成</li>\\n<li>拷贝构造函数（<a href=\\"\\">Copy constructors</a>）</li>\\n<li>拷贝赋值操作符（<a href=\\"https://en.cppreference.com/w/cpp/language/copy_assignment\\">Copy assignment operator</a>）</li>\\n<li>移动构造函数（<a href=\\"https://en.cppreference.com/w/cpp/language/move_constructor\\">Move constructors</a>）</li>\\n<li>移动赋值操作符号（<a href=\\"\\">Move assignment operator</a>）</li>\\n</ul>\\n<p>一个简单的例子如下</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">class T {\\n public:\\n  T(); // Default constructor\\n  T(T&amp; rhs); // Copy constructor\\n  T(T&amp;&amp; rhs); // Move constructor\\n  T&amp; operator=(T&amp; rhs); // Copy assignment operator\\n  T&amp; operator=(T&amp;&amp; rhs); // Move assignment operator\\n  ~T();\\n};</code></pre>\\n\\n\\n<h3 id=\\"_8\\">拷贝构造函数</h3>\\n<p>定义：构造函数的一种，第一个参数为<code>T&amp;‍</code>, <code>const T&amp;‍</code>, <code>volatile T&amp;‍</code>, or <code>const volatile T&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>何时调用：初始化（<code>T t1 = t2</code>或<code>T t1(t2)</code>）、函数传参（<code>void f(T t)</code>）、函数返回（<code>return t;</code>）</p>\\n<h3 id=\\"_9\\">移动构造函数</h3>\\n<p>定义：构造函数的一种，第一个参数为<code>T&amp;&amp;‍</code>, <code>const T&amp;&amp;‍</code>, <code>volatile T&amp;‍&amp;</code>, or <code>const volatile T&amp;&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>调用时机：初始化（<code>T t1 = std::move(t2);</code> 或 <code>T t1(std::move(t2));</code>）、函数传参（<code>f(std::move(t));</code>，其中f声明为<code>void f(T);</code>）、函数返回（<code>return std::move(t);</code>）</p>\\n<h3 id=\\"_10\\">拷贝赋值操作符</h3>\\n<p>定义：重载=的一种，第一个参数为<code>T</code>, <code>T&amp;‍</code>, <code>const T&amp;‍</code>, <code>volatile T&amp;‍</code>, or <code>const volatile T&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>注意到只有当参数为<code>T</code>，才可用swap的方法来实现拷贝赋值，否则不行，因为是常引用</p>\\n<h3 id=\\"_11\\">移动赋值操作符</h3>\\n<p>定义：重载=的一种，参数同移动构造函数</p>\\n<p>功能是直接将对象的资源“偷来”转移到被赋值的对象上（原对象的资源会成为未定义状态或空）</p>\\n<h3 id=\\"_12\\">成员函数和非成员函数</h3>\\n<p>非成员函数就是普通函数（c风格）</p>\\n<p>成员函数是面向对象的那种，只能在类里面声明</p>\\n<p>成员函数最后的 const 是用来修饰this指针的</p>\\n<h3 id=\\"explicit\\">explicit</h3>\\n<p>https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean</p>\\n<p><code>Str a = b;</code></p>\\n<p>用explicit后需要改成 <code>Str a{b};</code>，但返回值永远不行</p>\\n<h3 id=\\"_13\\">左值、右值和引用</h3>\\n<p>https://zh4ui.net/post/2018-08-07-cplusplus-return-value-or-reference/</p>\\n<p>不能放在等号左边的是右值</p>\\n<p>能放在等号左边的是左值</p>\\n<h3 id=\\"defaultdelete\\">default/delete</h3>\\n<p>default: 自定义了带参数的构造函数后，编译器是不会再自动提供默认的无参版本了，若需则用default</p>\\n<p>delete: 例如禁止使用拷贝构造函数，显示指示编译器不生成函数的默认版本，此后重载该函数非法</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">class MyClass\\n{\\n  public:\\n    MyClass() = default;\\n    MyClass(int i): data(i) {}\\n    MyClass(const MyClass &amp;) = delete;\\n  private:\\n    int data;\\n}</code></pre>\\n\\n\\n<h3 id=\\"_14\\">函数重载</h3>\\n<p>同名是指函数名字相同，同参是指参数列表相同（参数中const xxx和xxx相同）</p>\\n<p>函数的签名：由函数名和参数列表构成，用<code>objdump -x</code>查看其SYMBOL TABLE，编译时不允许有同签名（即同名同参）的函数</p>\\n<p>函数重载：当函数同名不同签名的时候发生</p>\\n<p>引用/常引用，指针/指向常的指针，是不同签名；而值是否为const都是同一签名</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;iostream&gt;\\n\\nint f(int x) { return 0; }\\n\\n// These two are allowed\\nvoid f(int *p) { }\\nvoid f(const int *p) { }\\n\\n// error: ambiguating new declaration of \'void f(int)\'\\n// void f(int x) {}\\n\\n// Since const xxx and xxx is same when pass by value\\n// In fact, void f(const int x) will be same as void f(int)\\n// error: redefinition of \'int f(int)\'\\n// void f(const int x) { }\\n\\n// error: redefinition of \'void f(int*)\'\\n// void f(int * const p) { }\\n\\nint main() {\\n  return 0;\\n}</code></pre>\\n\\n\\n<h3 id=\\"_15\\">操作符重载</h3>\\n<ul>\\n<li>全局operator new/delete[]可以重载，可以用来检测内存情况</li>\\n<li>类本身的operator new/delete</li>\\n</ul>\\n<p>二元操作符推荐写成非成员</p>\\n<p>各种重载的推荐写法（其中类型其实支持自定义，但通常这么写）</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">// T.h\\nusing namespace std;\\nclass T {\\n public:\\n  bool operator==(const T&amp; lhs, const T&amp; rhs);\\n\\n\\n  // a++/++a\\n  const T operator++(int);// Return const T to avoid a++ = b\\n  T&amp; operator++();\\n\\n  // Binary operations\\n  // Return const T to avoid a + b = c\\n  friend const T operator+(const T&amp; lhs, const T&amp; rhs);\\n\\n  // IO\\n  friend istream&amp; operator&gt;&gt;(istream &amp;is, T&amp; rhs);\\n  friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const T&amp; lhs);\\n};\\n// T.cc</code></pre>\\n\\n\\n<h2 id=\\"_16\\">继承和多态</h2>\\n<p>继承的种类：单继承（<code>Derived: Base</code>）、多继承（<code>Derived: Base1, Base2</code>）、多级继承（<code>DDerived: Derived: Base</code>）、混合继承（<code>DDerived: (Derived1, Derived2): Base</code>）</p>\\n<p>多态的实现原理：理解vtable，vptr，vtable每个类只有一张，在编译时就固定在内存中</p>\\n<p>编译器会在构造函数中的最后插入初始化vptr的代码，故在构造函数中调用虚函数是不生效的</p>\\n<p>构造时先调用基类构造函数（可以在初始化列表上指定调用哪种，否则调用默认构造函数），析构时后后调用基类析构函数，故<strong>基类析构函数一定要设置成virtual</strong></p>\\n<p>派生类的大小=基类大小+派生类成员大小+4B（vptr大小）</p>\\n<p>参考资料：</p>\\n<ol>\\n<li><a href=\\"https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/\\">the virtual table</a></li>\\n<li><a href=\\"https://stackoverflow.com/questions/1321062/object-layout-in-case-of-virtual-functions-and-multiple-inheritance\\">继承的内存布局</a></li>\\n<li><a href=\\"https://cs.nyu.edu/courses/fall16/CSCI-UA.0470-001/slides/MemoryLayoutMultipleInheritance.pdf\\">多继承的内存布局</a></li>\\n</ol>\\n<h3 id=\\"_17\\">访问控制</h3>\\n<p>对派生类内部来说</p>\\n<table>\\n<thead>\\n<tr>\\n<th>基类</th>\\n<th>public继承</th>\\n<th>protected继承</th>\\n<th>private继承</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>private</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>protected</td>\\n<td>protected</td>\\n<td>protected</td>\\n<td><strong>private</strong></td>\\n</tr>\\n<tr>\\n<td>public</td>\\n<td>public</td>\\n<td>protected</td>\\n<td><strong>private</strong></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>对外部对象来说（即包括<code>A a; a.f();</code>）</p>\\n<table>\\n<thead>\\n<tr>\\n<th>基类</th>\\n<th>public继承</th>\\n<th>protected继承</th>\\n<th>private继承</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>private</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>protected</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>public</td>\\n<td><strong>可见</strong></td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>测试例子如下</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;iostream&gt;\\nusing namespace std;\\n\\nclass Base {\\npublic:\\n  void bpublic() { cout &lt;&lt; &quot;Base public&quot; &lt;&lt; endl;}\\nprotected:\\n  void bprotected() { cout &lt;&lt; &quot;Base protected&quot; &lt;&lt; endl;}\\nprivate:\\n  void bprivate() { cout &lt;&lt; &quot;Base private&quot; &lt;&lt; endl;}\\n};\\nclass DerivedPublic: public Base {\\npublic:\\n  void test() { bpublic(); bprotected(); // bprivate();\\n  }\\n};\\nclass DerivedProtected: protected Base {\\npublic:\\n  void test() { bpublic(); bprotected(); // bprivate();\\n  }\\n};\\nclass DerivedPrivate: private Base {\\npublic:\\n  void test() { bpublic(); bprotected(); // bprivate();\\n  }\\n};\\n\\nint main() {\\n  DerivedPublic d1; DerivedProtected d2; DerivedPrivate d3;\\n  d1.test(); d2.test(); d3.test();\\n  d1.bpublic(); // d1.bprotected(); d1.bprivate();\\n  // d2.bpublic(); d2.bprotected(); d2.bprivate();\\n  // d3.bpublic(); d3.bprotected(); d3.bprivate();\\n  return 0;\\n}</code></pre>\\n\\n\\n<h3 id=\\"_18\\">静态绑定和动态绑定</h3>\\n<p>静态绑定：以非指针非引用来调用某个函数是可以在编译时确定是哪个函数</p>\\n<p>动态绑定：以指针/引用来调用某个函数需要在运行时才能知道调用的是哪个函数</p>\\n<h3 id=\\"_19\\">混合继承</h3>\\n<p>混合继承时，父类的共同父类会被重复多次，因为每个父类中都会有一份</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;iostream&gt;\\n#include &lt;cassert&gt;\\n\\nusing namespace std;\\n\\nclass Base {\\n public:\\n  int b;\\n};\\n\\nclass Mid1: public Base {\\n public:\\n  int m1;\\n};\\n\\nclass Mid2: public Base {\\n public:\\n  long long m2;\\n};\\n\\nclass Derived: public Mid1, public Mid2 {\\n public:\\n  int d;\\n};\\n\\nint main() {\\n  Derived d;\\n  Mid1 *pm1 = &amp;d;\\n  Mid2 *pm2 = &amp;d;\\n\\n  /* The memory layout of Derived\\n   * [Mid1, Mid2, d] = [Mid1.Base::b, m1, Mid2.Base::b, m2, d]\\n   * Thus, when casting a Derived pointer to Mid2, a shift \\n   * occurs that it then points to Mid2 in the Derived\\n   */\\n\\n  // 32 8 16\\n  cout &lt;&lt; sizeof(d) &lt;&lt; \' \' &lt;&lt; sizeof(*pm1) &lt;&lt; \' \' &lt;&lt; sizeof(*pm2);\\n\\n  assert(pm1 == &amp;d &amp;&amp; pm2 == (void *)&amp;d + sizeof(*pm1));\\n\\n  // The following line causes error: \\n  // \'Base\' is an ambiguous base of \'Derived\'\\n  // Base *pb = &amp;d;\\n\\n  return 0;\\n}</code></pre>\\n\\n\\n<h3 id=\\"_20\\">切片</h3>\\n<p>对象按指针/引用传递时，不会发生切片，而对象按值传递时，会发生切片，如</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">class Derived: public Base {...};\\nvoid describe(Base b);\\ndescribe(derived) is the same as describe((Base)derived)</code></pre>\\n\\n\\n<h3 id=\\"_21\\">函数覆盖</h3>\\n<p>函数覆盖（<a href=\\"https://en.cppreference.com/w/cpp/language/override\\">Override</a>）的定义是一个派生类virtual函数覆盖另外基类的virtual同名同参函数，给成员函数修饰override后，编译器会验证其是虚函数且必覆盖掉了基类的某个虚函数，否则报错。</p>\\n<p>虚函数建议放在private下</p>\\n<p>一旦派生类中某个函数同基类某个virtual函数同签名，则会自动变成virtual，并产生函数覆盖，若返回类型不同，则报错</p>\\n<h3 id=\\"_22\\">函数隐藏</h3>\\n<p>函数覆盖：覆盖virtual</p>\\n<p>函数隐藏：派生类若定义了和基类同名函数（仅函数名相同即可，不含返回值/const），则不能直接调用基类的此函数，但仍可用<code>Base::f</code>调用</p>\\n<p>同名即隐藏（除非都是virtual）</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">#include &lt;iostream&gt;\\n\\nusing namespace std;\\n\\nclass Base {\\n public:\\n  void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; };\\n  virtual void vf() { cout &lt;&lt; &quot;Base::vf&quot; &lt;&lt; endl; }\\n};\\nclass Derived0: public Base {\\n};\\nclass Derived1: public Base {\\n public:\\n  void f() { cout &lt;&lt; &quot;Derived1::f&quot; &lt;&lt; endl; }\\n  void vf() { cout &lt;&lt; &quot;Derived1::vf&quot; &lt;&lt; endl; }\\n};\\nclass Derived2: public Base {\\n public:\\n  int f() { cout &lt;&lt; &quot;Derived2::f&quot; &lt;&lt; endl; return 0; }\\n  void vf(int) { cout &lt;&lt; &quot;Derived2::vf&quot; &lt;&lt; endl; }\\n  // error: conflicting return type specified for \'virtual int Derived2::vf()\'\\n  // int vf() {}\\n  void vf() override { cout &lt;&lt; &quot;Derived2::vf&quot; &lt;&lt; endl; }\\n};\\nclass Derived3: public Base {\\n public:\\n  void f(int) { cout &lt;&lt; &quot;Derived3::f&quot; &lt;&lt; endl; }\\n};\\nclass Derived4: public Base {\\n public:\\n  void f() const { cout &lt;&lt; &quot;Derived4::f&quot; &lt;&lt; endl; }\\n};\\n\\nint main() {\\n  Derived0 d0;\\n  Derived1 d1;\\n  Derived2 d2;\\n  Derived3 d3;\\n  Derived4 d4;\\n\\n  // All call f of derived class\\n  d1.f();\\n  d2.f();\\n  d3.f(0);\\n  d4.f();\\n\\n  // d0/d1 should be public derived from Base or Base::f is inaccessible\\n  d0.f(); \\n  d1.Base::f();\\n\\n  d0.vf();\\n  d1.vf();\\n  d2.vf(0);\\n  d2.vf();\\n\\n  return 0;\\n}</code></pre>\\n\\n\\n<h3 id=\\"_23\\">单例模式</h3>\\n<p>构造析构放private，拷贝移动构造和赋值delete</p>\\n<pre class=\\"codehilite\\"><code class=\\"language-c++ linenums\\">static Singleton&amp; Singleton::getInstance()\\n{\\n    static Singleton instance;\\n    return instance;\\n}</code></pre>\\n\\n\\n<p>采用c++11及以上版本编译，可以支持线程安全，lazy-initialize，自动销毁.</p>","tags":["notes","cpp"],"title":"OOP Notes","updated_at":"2020-07-18T10:42:23.558726","url":"/docs/course/oop-notes"}')}}]);
//# sourceMappingURL=chunk-2d0dd490.474630a1.js.map