(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b16bf"],{"207b":function(t){t.exports=JSON.parse('{"created_at":"2020-10-17T12:00:02+08:00","excerpt":"> 反之亦然同理，推论自然成立，略去过程QED，由上可知证毕。","html":"<blockquote>\\n<p>西江月 证明</p>\\n<p>即得易见平凡，仿照上例显然。留作习题答案略，读者自证不难。\\n反之亦然同理，推论自然成立，略去过程QED，由上可知证毕。</p>\\n</blockquote>\\n<h2 id=\\"_1\\">基本概念</h2>\\n<p>图</p>\\n<h3 id=\\"graphical\\">可图（Graphical）</h3>\\n<p>可图化/可简单图化：给定n个顶点的度数（度序列），能否构成无向图/无向简单图</p>\\n<p><strong>定理</strong>（Havel-Hakimi）：单调不增的非负整数的度序列<script type=\\"math/tex\\">d_1\\\\ge  .., \\\\ge d_n<\/script>是可图化的，当且仅当度序列 <script type=\\"math/tex\\">d_2 - 1, ..., d_{d_1 + 1} -1, ..., d_n<\/script>是可图化的\\n<strong>证明</strong>：充分性显然，必要性易证（可图化的图G中，可以通过增删边使<script type=\\"math/tex\\">v_1<\/script>和<script type=\\"math/tex\\">v_2, ..., v_{d_1+1}<\/script>相邻）</p>\\n<p>可图化问题：尽可能地添加自环即可判定，即<script type=\\"math/tex\\">\\\\sum d[u] \\\\text{mod} 2 <\/script>是否等于0\\n可简单图化：将度数序列按从大到小排序，每次删除第一个点v[0]，并对其后的d[v[0]]个点，度数减一，循环直至所有点度数为0，若途中出现度数为负的情况则不可简单图化。\\n可简单图化的唯一性：其后的d[v[0]]个点中的最后一个点的度数是否等于再下一个点的度数，若相等说明可以交换这两个点再连边，得到不同的图</p>\\n<p>可简单图化需用Havel-Hakimi定理：将度数序列按从大到小排序，每次删除第一个点v[0]，并对其后的d[v[0]]个点，度数减一，循环直至所有点度数为0，若途中出现度数为负的情况则不可简单图化。</p>\\n<h2 id=\\"_2\\">二分图</h2>\\n<h2 id=\\"_3\\">最小生成树</h2>\\n<p>最优子结构：MST的子树也是MST</p>\\n<p>负边权可以通过都加上某个大正数完成（为什么最短路不能？因为生成树的边数唯一）</p>\\n<p>正确性证明：保证子树是MST</p>\\n<h3 id=\\"kruskal\\">Kruskal</h3>\\n<p>原理：每次选择边权最小的边，若加入后不会成环（两端点的属于不同并查集），则加入并更新并查集。\\n复杂度（假设图连通）：排序<script type=\\"math/tex\\">O(E\\\\log E)<\/script>，<script type=\\"math/tex\\">O(E)<\/script>次并查集操作 <script type=\\"math/tex\\">O(E\\\\alpha(V))  = O(E\\\\log V))<\/script>，故总的复杂度为<script type=\\"math/tex\\">O(E\\\\log E)<\/script>或<script type=\\"math/tex\\">O(E\\\\log V)<\/script>，因为<script type=\\"math/tex\\">E\\\\le V^2<\/script>\\n正确性证明：算法过程中保证了每个并查集都是一棵MST</p>\\n<h3 id=\\"prim\\">Prim</h3>\\n<p>原理：类似Dijkstra算法，每次加入距离当前已选点集最近的点加入\\n复杂度：同Dijkstra算法，用斐波那契堆，<script type=\\"math/tex\\">O(E+VlogV)<\/script>\\n正确性证明：保证已经加入的点构成MST</p>\\n<h2 id=\\"_4\\">最优比例生成树</h2>\\n<p>poj 2728 Desert King</p>\\n<h2 id=\\"_5\\">最短路径算法</h2>\\n<p>最长路径不具有最优子结构</p>\\n<h3 id=\\"single-source-shortest-path\\">Single source shortest path</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>适用情况</th>\\n<th>算法</th>\\n<th>复杂度</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>无边权</td>\\n<td>BFS</td>\\n<td>\\n<script type=\\"math/tex\\">O(V+E)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>无负边权</td>\\n<td>Dijkstra</td>\\n<td>\\n<script type=\\"math/tex\\">O(E + V\\\\log V)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>所有情况</td>\\n<td>Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>DAG</td>\\n<td>拓扑排序 + 1 round Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(V+E)<\/script>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\"dijkstra\\">Dijkstra</h4>\\n<p>维护已计算好的最短路径的节点</p>\\n<h4 id=\\"bellman-ford\\">Bellman-Ford</h4>\\n<p>\\n<script type=\\"math/tex\\">\\\\delta(s, v_i) = \\\\delta(s, v_{i-1}) + w(v_{i-1}, v_i)<\/script>\\n</p>\\n<p>对于一条最短路来说，每次循环都会使得最短路的有效长度（前k个点距离s的最短距离已算出）加1（除非无法再加）</p>\\n<p>由于最短路最长不超过节点数，故算法为两层循环，外层遍历所有点，内层遍历所有边</p>\\n<p>SPFA：TODO</p>\\n<h4 id=\\"difference-constraint\\">Difference constraint</h4>\\n<p>\\n<script type=\\"math/tex\\">x_j-x_i\\\\le w_{ij}<\/script>\\n</p>\\n<p>将差分约束方程转换成图，充要条件</p>\\n<ul>\\n<li>若负环存在，则无解</li>\\n<li>若负环不存在，则有解（证明：加一个到所有节点的s，令<script type=\\"math/tex\\">x_i=\\\\delta(s, v_i)<\/script>即可）</li>\\n</ul>\\n<p>于是可用Bellman-Ford来解决</p>\\n<h3 id=\\"all-pairs-shortest-path\\">All-pairs shortest path</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>适用情况</th>\\n<th>算法</th>\\n<th>复杂度</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>无边权</td>\\n<td>V次BFS</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>无负边权</td>\\n<td>V次Dijkstra</td>\\n<td>\\n<script type=\\"math/tex\\">O(VE + V^2\\\\log V)=O(VE)<\/script>\\n</td>\\n</tr>\\n<tr>\\n<td>所有情况*</td>\\n<td>V次Bellman-Ford</td>\\n<td>\\n<script type=\\"math/tex\\">O(V^2E)<\/script>\\n</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>判断负环是否存在的两种方法</p>\\n<ul>\\n<li>通过判断对角线上是否为负（到自己的路径为负，即负环）</li>\\n<li>在运行一轮算法，若边权改变了，则存在负环</li>\\n</ul>\\n<p>*用以下三种方法来优化适用所有情况的多点源最短路算法</p>\\n<h4 id=\\"matrix-multiplication\\">Matrix multiplication</h4>\\n<p>DP方程 <script type=\\"math/tex\\">d_{ij}^{(m)} = \\\\min \\\\{ d_{ik}^{(m-1)} + w_{kj}\\\\}<\/script>\\n</p>\\n<p>看作矩阵乘法 <script type=\\"math/tex\\">D^{(m)} = D^{(m-1)} \\\\otimes A = D^{(0)} \\\\otimes A^{m}<\/script>，<script type=\\"math/tex\\">D^{(0)} = \\\\left[\\\\begin{matrix} 0 & \\\\infin & \\\\infin \\\\\\\\ \\\\infin & ... & \\\\infin \\\\\\\\ \\\\infin & \\\\infin & 0   \\\\end{matrix}\\\\right]<\/script>\\n</p>\\n<p>用divider-and-conquer做幂运算，复杂度为<script type=\\"math/tex\\">O(V^3 \\\\log V)<\/script>\\n</p>\\n<ul>\\n<li>但不能用Strassen</li>\\n</ul>\\n<h4 id=\\"floyd-warshall\\">Floyd-Warshall</h4>\\n<p>DP方程：从i到j的只用到前k个点的最短路径长度 <script type=\\"math/tex\\">d_{ij}^{k} = \\\\min \\\\left\\\\{ d_{ij}^{k-1}, d_{ik}^{k-1} + d_{kj}^{k-1} \\\\right\\\\}<\/script>\\n</p>\\n<p>复杂度<script type=\\"math/tex\\">O(V^3)<\/script>\\n</p>\\n<h4 id=\\"johnsons-algorithm\\">Johnson\'s algorithm</h4>\\n<ol>\\n<li>先将所有边权变成非负，即寻找h 使得 <script type=\\"math/tex\\">w_h(u, v) = w(u, v) + h(u) - h(v) \\\\ge 0<\/script>\\n</li>\\n</ol>\\n<p>这是差分约束问题 <script type=\\"math/tex\\">h(v)- h(u) \\\\le w(u, v)<\/script>，可使用 Bellman-Ford 完成或找到负环</p>\\n<p>复杂为 <script type=\\"math/tex\\">O(VE)<\/script>\\n</p>\\n<ol>\\n<li>再用V次Dijkstra算法找到<script type=\\"math/tex\\">\\\\delta_h(u, v)<\/script>\\n</li>\\n</ol>\\n<p>复杂度为 <script type=\\"math/tex\\">O(VE + V^2\\\\log V)<\/script>\\n</p>\\n<ol>\\n<li>由 <script type=\\"math/tex\\">\\\\delta_h(u, v) = \\\\delta(u, v) + h(u) - h(v)<\/script> 可反推出<script type=\\"math/tex\\">\\\\delta(u, v)<\/script>\\n</li>\\n</ol>\\n<p>复杂度为 <script type=\\"math/tex\\">O(V^2)<\/script>\\n</p>\\n<p>故总复杂度为<script type=\\"math/tex\\">O(VE + V^2\\\\log V)=O(VE)<\/script>\\n</p>\\n<h2 id=\\"_6\\">网络流</h2>\\n<p>有向图和无向图的残差网络的区别是，无向图初始正向边权等于反向边权等于容量，而有向图正向边权等于容量，反向边权等于0</p>\\n<h3 id=\\"_7\\">概念</h3>\\n<ul>\\n<li>\\n<p>流、割（点割集）、割集（边割集）、割(A,B)的容量<script type=\\"math/tex\\">c(A,B)=\\\\sum_\\\\text{e out of A}c_e<\/script>\\n</p>\\n</li>\\n<li>\\n<p>残量网络：为了可以撤销操作</p>\\n</li>\\n<li>\\n<p>最大流、最小割</p>\\n</li>\\n</ul>\\n<h3 id=\\"ford-fulkerson\\">Ford-Fulkerson</h3>\\n<p>不断增广，直到没有增广路为止</p>\\n<p>\\n<script type=\\"math/tex\\">O(|E|max f) <\/script>，f是最大流大小</p>\\n<h3 id=\\"dinic\\">Dinic</h3>\\n<p>TODO</p>\\n<h3 id=\\"_8\\">预流推进</h3>\\n<p>TODO</p>\\n<h3 id=\\"stoer-wagner\\">Stoer-Wagner</h3>\\n<p>求解非负无向图的全局最小割</p>\\n<p>TODO</p>\\n<h3 id=\\"_9\\">技巧和例子</h3>\\n<p>技巧：超级源和超级汇、分点</p>\\n<h4 id=\\"baseball-elimination\\">Baseball Elimination</h4>\\n<p>判断队伍i是否仍有机会取胜，源为分发剩余比赛场数到每个比赛节点，每个比赛节点分配胜利场数到这两个参与此比赛的队伍节点，队伍节点到汇则是其获胜场数与i获胜常数之差</p>\\n<h4 id=\\"_10\\">最小割唯一性</h4>\\n<p>先跑一遍最大流，然后在残留网络中分别从源点和汇点出发dfs，只有当该边还有流量可用时可以访问下一个顶点，最后如果所有顶点都访问了，那么就是唯一的，否则不唯一。</p>\\n<h4 id=\\"_11\\">最少边数最小割</h4>\\n<p>将每条边的容量乘以一个大数字k（大于边数加一）再加1，然后计算最大流<script type=\\"math/tex\\">f_{max}<\/script>，最大流模k即为最大流的最小边数</p>\\n<p>另一种方法是，把未满流的边容量置为<script type=\\"math/tex\\">\\\\infin<\/script>，满流的边容量置为1，然后计算最大流。可以发现，这两种方法在边权时正整数的情况下是等价的（可以将第一种方法视作，k个原图将叠加后，再加个所有边权为1的图，乘以k是为了给未满流的边添加更大的容量，使其相当于无穷，并能填补满流边成k后加上的1）。</p>\\n<h4 id=\\"_12\\">平面图最大流</h4>\\n<p>TODO</p>\\n<h2 id=\\"_13\\">费用流</h2>\\n<p>TODO</p>","tags":[{"name":"graph","url":"/tags/graph"},{"name":"math","url":"/tags/math"}],"title":"图论笔记","updated_at":"2020-10-17T12:00:02+08:00","url":"/docs/course/graph"}')}}]);
//# sourceMappingURL=chunk-2d0b16bf.b4500b60.js.map