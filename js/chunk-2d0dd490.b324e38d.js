(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0dd490"],{8178:function(s){s.exports=JSON.parse('{"created_at":"2020-07-22T12:51:20+08:00","excerpt":"考试题型：","html":"<p>考试题型：</p>\\n<ul>\\n<li>选择题：</li>\\n<li>操作符重载（Overload）、函数覆盖（Override）、函数隐藏（Hiding）</li>\\n<li>填空题，填3行代码s</li>\\n<li>注意初始化</li>\\n<li>看代码写输出</li>\\n<li>编程题，两道大题</li>\\n<li>重载：操作符（二元/一元）、输入输出，二元操作建议定义在类外，如需访问私有成员，则在类内定义为friend\\n    <code>c++\\n    class T {\\n    public:\\n      friend T operator+(const T&amp;lhs, const T&amp; rhs)) const;\\n      friend istream&amp; operator&gt;&gt;(istream &amp;is, const T&amp; xx);\\n    }</code></li>\\n<li>C++文件操作，split的实现</li>\\n<li>尽可能地用const修饰</li>\\n<li>资源类需要移动赋值操作符号、移动构造函数、拷贝赋值操作符、拷贝构造函数</li>\\n<li><code>#ifdef</code>，<code>#include</code>相关头文件，<code>using namespace std;</code></li>\\n<li>stl中vector, list的使用</li>\\n</ul>\\n<h2 id=\\"_1\\">基础</h2>\\n<p>形式参数（形参）：定义函数时函数名后括号中的变量名\\n实际参数（实参）：调用函数时函数名后括号中的表达式</p>\\n<h3 id=\\"_2\\">静态局部变量</h3>\\n<p>C++中的静态局部变量</p>\\n<ul>\\n<li>内存分配在编译完成（同C）</li>\\n<li>初次执行时会调用构造函数（初始化），之后不再调用（通过某个bit来判断是否是第一次），故若函数未被执行，则不会初始化</li>\\n<li>main之后会调用析构函数</li>\\n</ul>\\n<h3 id=\\"_3\\">引用</h3>\\n<p>引用/指针和常引用/指针的区别和写法</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n36\\n37\\n38\\n39\\n40\\n41</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;cassert&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">a</span> <span class=\\"o\\">=</span> <span class=\\"mi\\">1</span><span class=\\"p\\">,</span> <span class=\\"n\\">b</span> <span class=\\"o\\">=</span> <span class=\\"mi\\">1</span><span class=\\"p\\">;</span>\\n\\n  <span class=\\"c1\\">// error: &#39;r&#39; declared as reference but not initialized </span>\\n  <span class=\\"c1\\">// int&amp; r;</span>\\n\\n  <span class=\\"c1\\">// error: cannot bind non-const lvalue reference of type </span>\\n  <span class=\\"c1\\">// &#39;int&amp;&#39; to an rvalue of type &#39;int&#39;</span>\\n  <span class=\\"c1\\">// int&amp; r = 1;</span>\\n\\n  <span class=\\"kt\\">int</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">lr</span> <span class=\\"o\\">=</span> <span class=\\"n\\">a</span><span class=\\"p\\">;</span>\\n  <span class=\\"kt\\">int</span><span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">rr</span> <span class=\\"o\\">=</span> <span class=\\"mi\\">1</span> <span class=\\"o\\">+</span> <span class=\\"mi\\">1</span><span class=\\"p\\">,</span> <span class=\\"n\\">rr2</span> <span class=\\"o\\">=</span> <span class=\\"mi\\">1</span><span class=\\"o\\">+</span><span class=\\"mi\\">1</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">rr</span> <span class=\\"o\\">+=</span> <span class=\\"mi\\">1</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">assert</span><span class=\\"p\\">(</span><span class=\\"o\\">&amp;</span><span class=\\"n\\">rr</span> <span class=\\"o\\">!=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">lr</span> <span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">rr</span> <span class=\\"o\\">!=</span> <span class=\\"n\\">lr</span><span class=\\"p\\">);</span>\\n\\n  <span class=\\"c1\\">// Reference to constant</span>\\n  <span class=\\"k\\">const</span> <span class=\\"kt\\">int</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">lrk</span> <span class=\\"o\\">=</span> <span class=\\"n\\">lr</span><span class=\\"p\\">;</span>\\n  <span class=\\"c1\\">// error: assignment of read-only reference &#39;lrk&#39;</span>\\n  <span class=\\"c1\\">// lrk += 1;</span>\\n\\n  <span class=\\"c1\\">// Reference cannot be const</span>\\n  <span class=\\"c1\\">// error: &#39;const&#39; qualifiers cannot be applied to &#39;int&amp;&#39;</span>\\n  <span class=\\"c1\\">// int &amp; const klr = lr;</span>\\n\\n  <span class=\\"c1\\">// Constant pointer</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"o\\">*</span> <span class=\\"k\\">const</span> <span class=\\"n\\">kptr</span> <span class=\\"o\\">=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">a</span><span class=\\"p\\">;</span>\\n  <span class=\\"c1\\">// error: assignment of read-only variable &#39;kptr&#39;</span>\\n  <span class=\\"c1\\">// kptr = &amp;b; </span>\\n\\n  <span class=\\"c1\\">// Pointer to const</span>\\n  <span class=\\"k\\">const</span> <span class=\\"kt\\">int</span> <span class=\\"o\\">*</span><span class=\\"n\\">ptrk</span> <span class=\\"o\\">=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">a</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">ptrk</span> <span class=\\"o\\">=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">b</span><span class=\\"p\\">;</span>\\n  <span class=\\"c1\\">// error: assignment of read-only location &#39;* ptrk&#39;</span>\\n  <span class=\\"c1\\">// *ptrk = 1;</span>\\n\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h2 id=\\"stl\\">STL</h2>\\n<h3 id=\\"_4\\">字符串处理</h3>\\n<p>字符串转换到double或int：<code>double atof (const char* str);</code> 和 <code>int atoi (const char * str);</code></p>\\n<p>子串：<code>string string::substr(iterator, len)</code></p>\\n<h3 id=\\"_5\\">算法</h3>\\n<p>TODO</p>\\n<p>sort(a.begin(), a.end())</p>\\n<p>upperbound</p>\\n<p>lowerbound</p>\\n<h3 id=\\"_6\\">输入输出和文件</h3>\\n<p><a href=\\"http://www.cplusplus.com/reference/fstream/fstream/open/\\">打开文件</a>：读（in）、写（out）、二进制模式（binary）、指针移至文件尾（ate）、追加写（app）、从头写（trunc）</p>\\n<p>内容读取：读取一行（<code>stream&amp; getline(char* s [, streamsize n [, char delim]]);</code>）、读取一个字符（get）、撤回读取字符（unget）</p>\\n<p>例子</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n36\\n37\\n38\\n39</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;fstream&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;cstring&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n\\n<span class=\\"n\\">string</span> <span class=\\"nf\\">getline</span><span class=\\"p\\">(</span><span class=\\"n\\">istream</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">is</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span>\\n  <span class=\\"kt\\">char</span> <span class=\\"n\\">c</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">string</span> <span class=\\"n\\">line</span><span class=\\"p\\">;</span>\\n  <span class=\\"k\\">do</span> <span class=\\"p\\">{</span>\\n    <span class=\\"n\\">c</span> <span class=\\"o\\">=</span> <span class=\\"n\\">is</span><span class=\\"p\\">.</span><span class=\\"n\\">get</span><span class=\\"p\\">();</span>\\n    <span class=\\"k\\">if</span> <span class=\\"p\\">(</span><span class=\\"n\\">c</span> <span class=\\"o\\">!=</span> <span class=\\"n\\">EOF</span><span class=\\"p\\">)</span> <span class=\\"n\\">line</span><span class=\\"p\\">.</span><span class=\\"n\\">push_back</span><span class=\\"p\\">(</span><span class=\\"n\\">c</span><span class=\\"p\\">);</span>\\n  <span class=\\"p\\">}</span> <span class=\\"k\\">while</span> <span class=\\"p\\">(</span><span class=\\"n\\">c</span> <span class=\\"o\\">!=</span> <span class=\\"sc\\">&#39;\\\\n&#39;</span> <span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">c</span> <span class=\\"o\\">!=</span> <span class=\\"n\\">EOF</span><span class=\\"p\\">);</span>\\n  <span class=\\"k\\">return</span> <span class=\\"n\\">line</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">getint</span><span class=\\"p\\">(</span><span class=\\"n\\">istream</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">is</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span>\\n  <span class=\\"kt\\">char</span> <span class=\\"n\\">c</span><span class=\\"p\\">;</span>\\n  <span class=\\"k\\">while</span> <span class=\\"p\\">((</span><span class=\\"n\\">c</span> <span class=\\"o\\">=</span> <span class=\\"n\\">is</span><span class=\\"p\\">.</span><span class=\\"n\\">get</span><span class=\\"p\\">())</span> <span class=\\"o\\">!=</span> <span class=\\"n\\">EOF</span> <span class=\\"o\\">&amp;&amp;</span> <span class=\\"p\\">(</span><span class=\\"n\\">c</span> <span class=\\"o\\">==</span> <span class=\\"sc\\">&#39; &#39;</span> <span class=\\"o\\">||</span> <span class=\\"n\\">c</span> <span class=\\"o\\">==</span> <span class=\\"sc\\">&#39;\\\\n&#39;</span><span class=\\"p\\">))</span> <span class=\\"p\\">;</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">x</span> <span class=\\"o\\">=</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n  <span class=\\"k\\">for</span> <span class=\\"p\\">(;</span> <span class=\\"sc\\">&#39;0&#39;</span> <span class=\\"o\\">&lt;=</span> <span class=\\"n\\">c</span> <span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">c</span> <span class=\\"o\\">&lt;=</span> <span class=\\"sc\\">&#39;9&#39;</span><span class=\\"p\\">;</span> <span class=\\"n\\">c</span> <span class=\\"o\\">=</span> <span class=\\"n\\">is</span><span class=\\"p\\">.</span><span class=\\"n\\">get</span><span class=\\"p\\">())</span> <span class=\\"p\\">{</span>\\n    <span class=\\"n\\">x</span> <span class=\\"o\\">*=</span> <span class=\\"mi\\">10</span><span class=\\"p\\">;</span>\\n    <span class=\\"n\\">x</span> <span class=\\"o\\">+=</span> <span class=\\"n\\">c</span><span class=\\"o\\">-</span><span class=\\"sc\\">&#39;0&#39;</span><span class=\\"p\\">;</span>\\n  <span class=\\"p\\">}</span>\\n  <span class=\\"k\\">if</span> <span class=\\"p\\">(</span><span class=\\"n\\">c</span> <span class=\\"o\\">!=</span> <span class=\\"n\\">EOF</span><span class=\\"p\\">)</span> <span class=\\"n\\">is</span><span class=\\"p\\">.</span><span class=\\"n\\">unget</span><span class=\\"p\\">();</span>\\n  <span class=\\"k\\">return</span> <span class=\\"n\\">x</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"n\\">fstream</span> <span class=\\"n\\">fs</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">fs</span><span class=\\"p\\">.</span><span class=\\"n\\">open</span><span class=\\"p\\">(</span><span class=\\"s\\">&quot;tmp&quot;</span><span class=\\"p\\">,</span> <span class=\\"n\\">fstream</span><span class=\\"o\\">::</span><span class=\\"n\\">in</span><span class=\\"p\\">);</span>\\n  <span class=\\"k\\">if</span> <span class=\\"p\\">(</span><span class=\\"o\\">!</span><span class=\\"n\\">fs</span><span class=\\"p\\">)</span> <span class=\\"n\\">cerr</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Can&#39;t open input file!&quot;</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">getint</span><span class=\\"p\\">(</span><span class=\\"n\\">fs</span><span class=\\"p\\">)</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span>\\n  <span class=\\"k\\">for</span> <span class=\\"p\\">(</span><span class=\\"n\\">string</span> <span class=\\"n\\">line</span> <span class=\\"o\\">=</span> <span class=\\"n\\">getline</span><span class=\\"p\\">(</span><span class=\\"n\\">fs</span><span class=\\"p\\">);</span> <span class=\\"n\\">line</span><span class=\\"p\\">.</span><span class=\\"n\\">size</span><span class=\\"p\\">()</span> <span class=\\"o\\">&gt;</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span> <span class=\\"n\\">line</span> <span class=\\"o\\">=</span> <span class=\\"n\\">getline</span><span class=\\"p\\">(</span><span class=\\"n\\">fs</span><span class=\\"p\\">))</span> <span class=\\"p\\">{</span>\\n    <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">line</span><span class=\\"p\\">;</span>\\n  <span class=\\"p\\">}</span>\\n  <span class=\\"n\\">fs</span><span class=\\"p\\">.</span><span class=\\"n\\">close</span><span class=\\"p\\">();</span>\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h2 id=\\"_7\\">类</h2>\\n<ul>\\n<li>默认构造函数：没有参数的构造函数，默认生成</li>\\n<li>拷贝构造函数（<a href=\\"\\">Copy constructors</a>）</li>\\n<li>拷贝赋值操作符（<a href=\\"https://en.cppreference.com/w/cpp/language/copy_assignment\\">Copy assignment operator</a>）</li>\\n<li>移动构造函数（<a href=\\"https://en.cppreference.com/w/cpp/language/move_constructor\\">Move constructors</a>）</li>\\n<li>移动赋值操作符号（<a href=\\"\\">Move assignment operator</a>）</li>\\n</ul>\\n<p>一个简单的例子如下</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre>1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"k\\">class</span> <span class=\\"nc\\">T</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"n\\">T</span><span class=\\"p\\">();</span> <span class=\\"c1\\">// Default constructor</span>\\n  <span class=\\"n\\">T</span><span class=\\"p\\">(</span><span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span> <span class=\\"c1\\">// Copy constructor</span>\\n  <span class=\\"n\\">T</span><span class=\\"p\\">(</span><span class=\\"n\\">T</span><span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span> <span class=\\"c1\\">// Move constructor</span>\\n  <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"k\\">operator</span><span class=\\"o\\">=</span><span class=\\"p\\">(</span><span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span> <span class=\\"c1\\">// Copy assignment operator</span>\\n  <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"k\\">operator</span><span class=\\"o\\">=</span><span class=\\"p\\">(</span><span class=\\"n\\">T</span><span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span> <span class=\\"c1\\">// Move assignment operator</span>\\n  <span class=\\"o\\">~</span><span class=\\"n\\">T</span><span class=\\"p\\">();</span>\\n<span class=\\"p\\">};</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_8\\">拷贝构造函数</h3>\\n<p>定义：构造函数的一种，第一个参数为<code>T&amp;‍</code>, <code>const T&amp;‍</code>, <code>volatile T&amp;‍</code>, or <code>const volatile T&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>何时调用：初始化（<code>T t1 = t2</code>或<code>T t1(t2)</code>）、函数传参（<code>void f(T t)</code>）、函数返回（<code>return t;</code>）</p>\\n<h3 id=\\"_9\\">移动构造函数</h3>\\n<p>定义：构造函数的一种，第一个参数为<code>T&amp;&amp;‍</code>, <code>const T&amp;&amp;‍</code>, <code>volatile T&amp;‍&amp;</code>, or <code>const volatile T&amp;&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>调用时机：初始化（<code>T t1 = std::move(t2);</code> 或 <code>T t1(std::move(t2));</code>）、函数传参（<code>f(std::move(t));</code>，其中f声明为<code>void f(T);</code>）、函数返回（<code>return std::move(t);</code>）</p>\\n<h3 id=\\"_10\\">拷贝赋值操作符</h3>\\n<p>定义：重载=的一种，第一个参数为<code>T</code>, <code>T&amp;‍</code>, <code>const T&amp;‍</code>, <code>volatile T&amp;‍</code>, or <code>const volatile T&amp;‍</code> 中的一个，且没有其他参数或其他参数均有默认值</p>\\n<p>注意到只有当参数为<code>T</code>，才可用swap的方法来实现拷贝赋值，否则不行，因为是常引用</p>\\n<h3 id=\\"_11\\">移动赋值操作符</h3>\\n<p>定义：重载=的一种，参数同移动构造函数</p>\\n<p>功能是直接将对象的资源“偷来”转移到被赋值的对象上（原对象的资源会成为未定义状态或空）</p>\\n<h3 id=\\"_12\\">成员函数和非成员函数</h3>\\n<p>非成员函数就是普通函数（c风格）</p>\\n<p>成员函数是面向对象的那种，只能在类里面声明</p>\\n<p>成员函数最后的 const 是用来修饰this指针的</p>\\n<h3 id=\\"explicit\\">explicit</h3>\\n<p>https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean</p>\\n<p><code>Str a = b;</code></p>\\n<p>用explicit后需要改成 <code>Str a{b};</code>，但返回值永远不行</p>\\n<h3 id=\\"_13\\">左值、右值和引用</h3>\\n<p>https://zh4ui.net/post/2018-08-07-cplusplus-return-value-or-reference/</p>\\n<p>不能放在等号左边的是右值</p>\\n<p>能放在等号左边的是左值</p>\\n<h3 id=\\"defaultdelete\\">default/delete</h3>\\n<p>default: 自定义了带参数的构造函数后，编译器是不会再自动提供默认的无参版本了，若需则用default</p>\\n<p>delete: 例如禁止使用拷贝构造函数，显示指示编译器不生成函数的默认版本，此后重载该函数非法</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre>1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"k\\">class</span> <span class=\\"nc\\">MyClass</span>\\n<span class=\\"p\\">{</span>\\n  <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n    <span class=\\"n\\">MyClass</span><span class=\\"p\\">()</span> <span class=\\"o\\">=</span> <span class=\\"k\\">default</span><span class=\\"p\\">;</span>\\n    <span class=\\"n\\">MyClass</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span> <span class=\\"n\\">i</span><span class=\\"p\\">)</span><span class=\\"o\\">:</span> <span class=\\"n\\">data</span><span class=\\"p\\">(</span><span class=\\"n\\">i</span><span class=\\"p\\">)</span> <span class=\\"p\\">{}</span>\\n    <span class=\\"n\\">MyClass</span><span class=\\"p\\">(</span><span class=\\"k\\">const</span> <span class=\\"n\\">MyClass</span> <span class=\\"o\\">&amp;</span><span class=\\"p\\">)</span> <span class=\\"o\\">=</span> <span class=\\"k\\">delete</span><span class=\\"p\\">;</span>\\n  <span class=\\"k\\">private</span><span class=\\"o\\">:</span>\\n    <span class=\\"kt\\">int</span> <span class=\\"n\\">data</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_14\\">函数重载</h3>\\n<p>同名是指函数名字相同，同参是指参数列表相同（参数中const xxx和xxx相同）</p>\\n<p>函数的签名：由函数名和参数列表构成，用<code>objdump -x</code>查看其SYMBOL TABLE，编译时不允许有同签名（即同名同参）的函数</p>\\n<p>函数重载：当函数同名不同签名的时候发生</p>\\n<p>引用/常引用，指针/指向常的指针，是不同签名；而值是否为const都是同一签名</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">f</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span> <span class=\\"n\\">x</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span> <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n\\n<span class=\\"c1\\">// These two are allowed</span>\\n<span class=\\"kt\\">void</span> <span class=\\"nf\\">f</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span> <span class=\\"o\\">*</span><span class=\\"n\\">p</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span> <span class=\\"p\\">}</span>\\n<span class=\\"kt\\">void</span> <span class=\\"nf\\">f</span><span class=\\"p\\">(</span><span class=\\"k\\">const</span> <span class=\\"kt\\">int</span> <span class=\\"o\\">*</span><span class=\\"n\\">p</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span> <span class=\\"p\\">}</span>\\n\\n<span class=\\"c1\\">// error: ambiguating new declaration of &#39;void f(int)&#39;</span>\\n<span class=\\"c1\\">// void f(int x) {}</span>\\n\\n<span class=\\"c1\\">// Since const xxx and xxx is same when pass by value</span>\\n<span class=\\"c1\\">// In fact, void f(const int x) will be same as void f(int)</span>\\n<span class=\\"c1\\">// error: redefinition of &#39;int f(int)&#39;</span>\\n<span class=\\"c1\\">// void f(const int x) { }</span>\\n\\n<span class=\\"c1\\">// error: redefinition of &#39;void f(int*)&#39;</span>\\n<span class=\\"c1\\">// void f(int * const p) { }</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_15\\">操作符重载</h3>\\n<ul>\\n<li>全局operator new/delete[]可以重载，可以用来检测内存情况</li>\\n<li>类本身的operator new/delete</li>\\n</ul>\\n<p>二元操作符推荐写成非成员</p>\\n<p>各种重载的推荐写法（其中类型其实支持自定义，但通常这么写）</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"c1\\">// T.h</span>\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">T</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">bool</span> <span class=\\"k\\">operator</span><span class=\\"o\\">==</span><span class=\\"p\\">(</span><span class=\\"k\\">const</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">lhs</span><span class=\\"p\\">,</span> <span class=\\"k\\">const</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span>\\n\\n\\n  <span class=\\"c1\\">// a++/++a</span>\\n  <span class=\\"k\\">const</span> <span class=\\"n\\">T</span> <span class=\\"k\\">operator</span><span class=\\"o\\">++</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span><span class=\\"p\\">);</span><span class=\\"c1\\">// Return const T to avoid a++ = b</span>\\n  <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"k\\">operator</span><span class=\\"o\\">++</span><span class=\\"p\\">();</span>\\n\\n  <span class=\\"c1\\">// Binary operations</span>\\n  <span class=\\"c1\\">// Return const T to avoid a + b = c</span>\\n  <span class=\\"k\\">friend</span> <span class=\\"k\\">const</span> <span class=\\"n\\">T</span> <span class=\\"k\\">operator</span><span class=\\"o\\">+</span><span class=\\"p\\">(</span><span class=\\"k\\">const</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">lhs</span><span class=\\"p\\">,</span> <span class=\\"k\\">const</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span>\\n\\n  <span class=\\"c1\\">// IO</span>\\n  <span class=\\"k\\">friend</span> <span class=\\"n\\">istream</span><span class=\\"o\\">&amp;</span> <span class=\\"k\\">operator</span><span class=\\"o\\">&gt;&gt;</span><span class=\\"p\\">(</span><span class=\\"n\\">istream</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">is</span><span class=\\"p\\">,</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">rhs</span><span class=\\"p\\">);</span>\\n  <span class=\\"k\\">friend</span> <span class=\\"n\\">ostream</span><span class=\\"o\\">&amp;</span> <span class=\\"k\\">operator</span><span class=\\"o\\">&lt;&lt;</span><span class=\\"p\\">(</span><span class=\\"n\\">ostream</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">os</span><span class=\\"p\\">,</span> <span class=\\"k\\">const</span> <span class=\\"n\\">T</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">lhs</span><span class=\\"p\\">);</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"c1\\">// T.cc</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h2 id=\\"_16\\">继承和多态</h2>\\n<p>继承的种类：单继承（<code>Derived: Base</code>）、多继承（<code>Derived: Base1, Base2</code>）、多级继承（<code>DDerived: Derived: Base</code>）、混合继承（<code>DDerived: (Derived1, Derived2): Base</code>）</p>\\n<p>多态的实现原理：理解vtable，vptr，vtable每个类只有一张，在编译时就固定在内存中</p>\\n<p>编译器会在构造函数中的最后插入初始化vptr的代码，故在构造函数中调用虚函数是不生效的</p>\\n<p>构造时先调用基类构造函数（可以在初始化列表上指定调用哪种，否则调用默认构造函数），析构时后后调用基类析构函数，故<strong>基类析构函数一定要设置成virtual</strong></p>\\n<p>派生类的大小=基类大小+派生类成员大小+4B（vptr大小）</p>\\n<p>参考资料：</p>\\n<ol>\\n<li><a href=\\"https://www.learncpp.com/cpp-tutorial/125-the-virtual-table/\\">the virtual table</a></li>\\n<li><a href=\\"https://stackoverflow.com/questions/1321062/object-layout-in-case-of-virtual-functions-and-multiple-inheritance\\">继承的内存布局</a></li>\\n<li><a href=\\"https://cs.nyu.edu/courses/fall16/CSCI-UA.0470-001/slides/MemoryLayoutMultipleInheritance.pdf\\">多继承的内存布局</a></li>\\n</ol>\\n<h3 id=\\"_17\\">访问控制</h3>\\n<p>对派生类内部来说</p>\\n<table>\\n<thead>\\n<tr>\\n<th>基类</th>\\n<th>public继承</th>\\n<th>protected继承</th>\\n<th>private继承</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>private</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>protected</td>\\n<td>protected</td>\\n<td>protected</td>\\n<td><strong>private</strong></td>\\n</tr>\\n<tr>\\n<td>public</td>\\n<td>public</td>\\n<td>protected</td>\\n<td><strong>private</strong></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>对外部对象来说（即包括<code>A a; a.f();</code>）</p>\\n<table>\\n<thead>\\n<tr>\\n<th>基类</th>\\n<th>public继承</th>\\n<th>protected继承</th>\\n<th>private继承</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>private</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>protected</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n<tr>\\n<td>public</td>\\n<td><strong>可见</strong></td>\\n<td>不可见</td>\\n<td>不可见</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>测试例子如下</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Base</span> <span class=\\"p\\">{</span>\\n<span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">bpublic</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Base public&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;}</span>\\n<span class=\\"k\\">protected</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">bprotected</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Base protected&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;}</span>\\n<span class=\\"k\\">private</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">bprivate</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Base private&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">DerivedPublic</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n<span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">test</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">bpublic</span><span class=\\"p\\">();</span> <span class=\\"n\\">bprotected</span><span class=\\"p\\">();</span> <span class=\\"c1\\">// bprivate();</span>\\n  <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">DerivedProtected</span><span class=\\"o\\">:</span> <span class=\\"k\\">protected</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n<span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">test</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">bpublic</span><span class=\\"p\\">();</span> <span class=\\"n\\">bprotected</span><span class=\\"p\\">();</span> <span class=\\"c1\\">// bprivate();</span>\\n  <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">DerivedPrivate</span><span class=\\"o\\">:</span> <span class=\\"k\\">private</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n<span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">test</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">bpublic</span><span class=\\"p\\">();</span> <span class=\\"n\\">bprotected</span><span class=\\"p\\">();</span> <span class=\\"c1\\">// bprivate();</span>\\n  <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"n\\">DerivedPublic</span> <span class=\\"n\\">d1</span><span class=\\"p\\">;</span> <span class=\\"n\\">DerivedProtected</span> <span class=\\"n\\">d2</span><span class=\\"p\\">;</span> <span class=\\"n\\">DerivedPrivate</span> <span class=\\"n\\">d3</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">d1</span><span class=\\"p\\">.</span><span class=\\"n\\">test</span><span class=\\"p\\">();</span> <span class=\\"n\\">d2</span><span class=\\"p\\">.</span><span class=\\"n\\">test</span><span class=\\"p\\">();</span> <span class=\\"n\\">d3</span><span class=\\"p\\">.</span><span class=\\"n\\">test</span><span class=\\"p\\">();</span>\\n  <span class=\\"n\\">d1</span><span class=\\"p\\">.</span><span class=\\"n\\">bpublic</span><span class=\\"p\\">();</span> <span class=\\"c1\\">// d1.bprotected(); d1.bprivate();</span>\\n  <span class=\\"c1\\">// d2.bpublic(); d2.bprotected(); d2.bprivate();</span>\\n  <span class=\\"c1\\">// d3.bpublic(); d3.bprotected(); d3.bprivate();</span>\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_18\\">静态绑定和动态绑定</h3>\\n<p>静态绑定：以非指针非引用来调用某个函数是可以在编译时确定是哪个函数</p>\\n<p>动态绑定：以指针/引用来调用某个函数需要在运行时才能知道调用的是哪个函数</p>\\n<h3 id=\\"_19\\">混合继承</h3>\\n<p>混合继承时，父类的共同父类会被重复多次，因为每个父类中都会有一份</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n45\\n46\\n47</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n<span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;cassert&gt;</span><span class=\\"cp\\"></span>\\n\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">b</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Mid1</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">m1</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Mid2</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">long</span> <span class=\\"kt\\">long</span> <span class=\\"n\\">m2</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Mid1</span><span class=\\"p\\">,</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Mid2</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">d</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"n\\">Derived</span> <span class=\\"n\\">d</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Mid1</span> <span class=\\"o\\">*</span><span class=\\"n\\">pm1</span> <span class=\\"o\\">=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">d</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Mid2</span> <span class=\\"o\\">*</span><span class=\\"n\\">pm2</span> <span class=\\"o\\">=</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">d</span><span class=\\"p\\">;</span>\\n\\n  <span class=\\"cm\\">/* The memory layout of Derived</span>\\n<span class=\\"cm\\">   * [Mid1, Mid2, d] = [Mid1.Base::b, m1, Mid2.Base::b, m2, d]</span>\\n<span class=\\"cm\\">   * Thus, when casting a Derived pointer to Mid2, a shift </span>\\n<span class=\\"cm\\">   * occurs that it then points to Mid2 in the Derived</span>\\n<span class=\\"cm\\">   */</span>\\n\\n  <span class=\\"c1\\">// 32 8 16</span>\\n  <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"k\\">sizeof</span><span class=\\"p\\">(</span><span class=\\"n\\">d</span><span class=\\"p\\">)</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"sc\\">&#39; &#39;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"k\\">sizeof</span><span class=\\"p\\">(</span><span class=\\"o\\">*</span><span class=\\"n\\">pm1</span><span class=\\"p\\">)</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"sc\\">&#39; &#39;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"k\\">sizeof</span><span class=\\"p\\">(</span><span class=\\"o\\">*</span><span class=\\"n\\">pm2</span><span class=\\"p\\">);</span>\\n\\n  <span class=\\"n\\">assert</span><span class=\\"p\\">(</span><span class=\\"n\\">pm1</span> <span class=\\"o\\">==</span> <span class=\\"o\\">&amp;</span><span class=\\"n\\">d</span> <span class=\\"o\\">&amp;&amp;</span> <span class=\\"n\\">pm2</span> <span class=\\"o\\">==</span> <span class=\\"p\\">(</span><span class=\\"kt\\">void</span> <span class=\\"o\\">*</span><span class=\\"p\\">)</span><span class=\\"o\\">&amp;</span><span class=\\"n\\">d</span> <span class=\\"o\\">+</span> <span class=\\"k\\">sizeof</span><span class=\\"p\\">(</span><span class=\\"o\\">*</span><span class=\\"n\\">pm1</span><span class=\\"p\\">));</span>\\n\\n  <span class=\\"c1\\">// The following line causes error: </span>\\n  <span class=\\"c1\\">// &#39;Base&#39; is an ambiguous base of &#39;Derived&#39;</span>\\n  <span class=\\"c1\\">// Base *pb = &amp;d;</span>\\n\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_20\\">切片</h3>\\n<p>对象按指针/引用传递时，不会发生切片，而对象按值传递时，会发生切片，如</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre>1\\n2\\n3</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"k\\">class</span> <span class=\\"nc\\">Derived</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{...};</span>\\n<span class=\\"kt\\">void</span> <span class=\\"nf\\">describe</span><span class=\\"p\\">(</span><span class=\\"n\\">Base</span> <span class=\\"n\\">b</span><span class=\\"p\\">);</span>\\n<span class=\\"n\\">describe</span><span class=\\"p\\">(</span><span class=\\"n\\">derived</span><span class=\\"p\\">)</span> <span class=\\"n\\">is</span> <span class=\\"n\\">the</span> <span class=\\"n\\">same</span> <span class=\\"n\\">as</span> <span class=\\"n\\">describe</span><span class=\\"p\\">((</span><span class=\\"n\\">Base</span><span class=\\"p\\">)</span><span class=\\"n\\">derived</span><span class=\\"p\\">)</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_21\\">函数覆盖</h3>\\n<p>函数覆盖（<a href=\\"https://en.cppreference.com/w/cpp/language/override\\">Override</a>）的定义是一个派生类virtual函数覆盖另外基类的virtual同名同参函数，给成员函数修饰override后，编译器会验证其是虚函数且必覆盖掉了基类的某个虚函数，否则报错。</p>\\n<p>虚函数建议放在private下</p>\\n<p>一旦派生类中某个函数同基类某个virtual函数同签名，则会自动变成virtual，并产生函数覆盖，若返回类型不同，则报错</p>\\n<h3 id=\\"_22\\">函数隐藏</h3>\\n<p>函数覆盖：覆盖virtual</p>\\n<p>函数隐藏：派生类若定义了和基类同名函数（仅函数名相同即可，不含返回值/const），则不能直接调用基类的此函数，但仍可用<code>Base::f</code>调用</p>\\n<p>同名即隐藏（除非都是virtual）</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre> 1\\n 2\\n 3\\n 4\\n 5\\n 6\\n 7\\n 8\\n 9\\n10\\n11\\n12\\n13\\n14\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n22\\n23\\n24\\n25\\n26\\n27\\n28\\n29\\n30\\n31\\n32\\n33\\n34\\n35\\n36\\n37\\n38\\n39\\n40\\n41\\n42\\n43\\n44\\n45\\n46\\n47\\n48\\n49\\n50\\n51\\n52\\n53\\n54\\n55\\n56\\n57</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"cp\\">#include</span> <span class=\\"cpf\\">&lt;iostream&gt;</span><span class=\\"cp\\"></span>\\n\\n<span class=\\"k\\">using</span> <span class=\\"k\\">namespace</span> <span class=\\"n\\">std</span><span class=\\"p\\">;</span>\\n\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">f</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Base::f&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">};</span>\\n  <span class=\\"k\\">virtual</span> <span class=\\"kt\\">void</span> <span class=\\"nf\\">vf</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Base::vf&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived0</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived1</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">f</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived1::f&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">vf</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived1::vf&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived2</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">int</span> <span class=\\"n\\">f</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived2::f&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">vf</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived2::vf&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n  <span class=\\"c1\\">// error: conflicting return type specified for &#39;virtual int Derived2::vf()&#39;</span>\\n  <span class=\\"c1\\">// int vf() {}</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">vf</span><span class=\\"p\\">()</span> <span class=\\"k\\">override</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived2::vf&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived3</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">f</span><span class=\\"p\\">(</span><span class=\\"kt\\">int</span><span class=\\"p\\">)</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived3::f&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n<span class=\\"k\\">class</span> <span class=\\"nc\\">Derived4</span><span class=\\"o\\">:</span> <span class=\\"k\\">public</span> <span class=\\"n\\">Base</span> <span class=\\"p\\">{</span>\\n <span class=\\"k\\">public</span><span class=\\"o\\">:</span>\\n  <span class=\\"kt\\">void</span> <span class=\\"n\\">f</span><span class=\\"p\\">()</span> <span class=\\"k\\">const</span> <span class=\\"p\\">{</span> <span class=\\"n\\">cout</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"s\\">&quot;Derived4::f&quot;</span> <span class=\\"o\\">&lt;&lt;</span> <span class=\\"n\\">endl</span><span class=\\"p\\">;</span> <span class=\\"p\\">}</span>\\n<span class=\\"p\\">};</span>\\n\\n<span class=\\"kt\\">int</span> <span class=\\"nf\\">main</span><span class=\\"p\\">()</span> <span class=\\"p\\">{</span>\\n  <span class=\\"n\\">Derived0</span> <span class=\\"n\\">d0</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Derived1</span> <span class=\\"n\\">d1</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Derived2</span> <span class=\\"n\\">d2</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Derived3</span> <span class=\\"n\\">d3</span><span class=\\"p\\">;</span>\\n  <span class=\\"n\\">Derived4</span> <span class=\\"n\\">d4</span><span class=\\"p\\">;</span>\\n\\n  <span class=\\"c1\\">// All call f of derived class</span>\\n  <span class=\\"n\\">d1</span><span class=\\"p\\">.</span><span class=\\"n\\">f</span><span class=\\"p\\">();</span>\\n  <span class=\\"n\\">d2</span><span class=\\"p\\">.</span><span class=\\"n\\">f</span><span class=\\"p\\">();</span>\\n  <span class=\\"n\\">d3</span><span class=\\"p\\">.</span><span class=\\"n\\">f</span><span class=\\"p\\">(</span><span class=\\"mi\\">0</span><span class=\\"p\\">);</span>\\n  <span class=\\"n\\">d4</span><span class=\\"p\\">.</span><span class=\\"n\\">f</span><span class=\\"p\\">();</span>\\n\\n  <span class=\\"c1\\">// d0/d1 should be public derived from Base or Base::f is inaccessible</span>\\n  <span class=\\"n\\">d0</span><span class=\\"p\\">.</span><span class=\\"n\\">f</span><span class=\\"p\\">();</span> \\n  <span class=\\"n\\">d1</span><span class=\\"p\\">.</span><span class=\\"n\\">Base</span><span class=\\"o\\">::</span><span class=\\"n\\">f</span><span class=\\"p\\">();</span>\\n\\n  <span class=\\"n\\">d0</span><span class=\\"p\\">.</span><span class=\\"n\\">vf</span><span class=\\"p\\">();</span>\\n  <span class=\\"n\\">d1</span><span class=\\"p\\">.</span><span class=\\"n\\">vf</span><span class=\\"p\\">();</span>\\n  <span class=\\"n\\">d2</span><span class=\\"p\\">.</span><span class=\\"n\\">vf</span><span class=\\"p\\">(</span><span class=\\"mi\\">0</span><span class=\\"p\\">);</span>\\n  <span class=\\"n\\">d2</span><span class=\\"p\\">.</span><span class=\\"n\\">vf</span><span class=\\"p\\">();</span>\\n\\n  <span class=\\"k\\">return</span> <span class=\\"mi\\">0</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<h3 id=\\"_23\\">单例模式</h3>\\n<p>构造析构放private，拷贝移动构造和赋值delete</p>\\n<table class=\\"codehilitetable\\"><tr><td class=\\"linenos\\"><div class=\\"linenodiv\\"><pre>1\\n2\\n3\\n4\\n5</pre></div></td><td class=\\"code\\"><div class=\\"codehilite\\"><pre><span></span><code><span class=\\"k\\">static</span> <span class=\\"n\\">Singleton</span><span class=\\"o\\">&amp;</span> <span class=\\"n\\">Singleton</span><span class=\\"o\\">::</span><span class=\\"n\\">getInstance</span><span class=\\"p\\">()</span>\\n<span class=\\"p\\">{</span>\\n    <span class=\\"k\\">static</span> <span class=\\"n\\">Singleton</span> <span class=\\"n\\">instance</span><span class=\\"p\\">;</span>\\n    <span class=\\"k\\">return</span> <span class=\\"n\\">instance</span><span class=\\"p\\">;</span>\\n<span class=\\"p\\">}</span>\\n</code></pre></div>\\n</td></tr></table>\\n\\n<p>采用c++11及以上版本编译，可以支持线程安全，lazy-initialize，自动销毁.</p>","tags":["notes","cpp"],"title":"OOP Notes","updated_at":"2020-07-22T12:51:20+08:00","url":"/docs/course/oop-notes"}')}}]);
//# sourceMappingURL=chunk-2d0dd490.b324e38d.js.map